---
title: obsolete
slug: >-
  Mozilla/Developer_guide/Build_Instructions/VC6_Build_Instructions/diff/obsolete
tags:
  - Build documentation
  - Developing Mozilla
  - Junk
---
<p>These are the patches that used to be required to build trunk with VC6 but are no longer necessary.</p>
<ul>
  <li>VC6 doesn't recognize inner classes as friends of outer classes and thus failed to compile HashKey, nsScriptEventHandlerOwnerTearoff or gfxSparseBitSet correctly, however HashDouble has now been removed and nsScriptEventHandlerOwnerTearoff is now a separate class so this friend declaration is now required anyway, while gfxSparseBitSet was moved from gfxWindowsFonts.h to gfxFontUtils.h:</li>
</ul>
<pre class="eval">Index: gfxTextRunCache.h
===================================================================
RCS file: /cvsroot/mozilla/gfx/thebes/public/gfxTextRunCache.h,v
retrieving revision 1.3
diff -u -r1.3 gfxTextRunCache.h
--- gfxTextRunCache.h	14 Oct 2006 07:25:55 -0000	1.3
+++ gfxTextRunCache.h	16 Nov 2006 21:11:53 -0000
@@ -95,14 +95,6 @@
         const GenericString* mString;
     };

-    static PRUint32 HashDouble(const double d) {
-        if (d == 0.0)
-            return 0;
-        int exponent;
-        double mantissa = frexp (d, &amp;exponent);
-        return (PRUint32) (2 * fabs(mantissa) - 1);
-    }
-
     template&lt;class T&gt;
     struct FontGroupAndStringHashKeyT : public PLDHashEntryHdr {
         typedef const T&amp; KeyType;
@@ -122,6 +114,15 @@
         }

         static KeyTypePointer KeyToPointer(KeyType aKey) { return &amp;aKey; }
+
+        static PRUint32 HashDouble(const double d) {
+            if (d == 0.0)
+                return 0;
+            int exponent;
+            double mantissa = frexp (d, &amp;exponent);
+            return (PRUint32) (2 * fabs(mantissa) - 1);
+        }
+
         static PLDHashNumber HashKey(KeyTypePointer aKey) {
             PRUint32 h1 = HashString(*(aKey-&gt;mString));
             PRUint32 h2 = HashString(aKey-&gt;mFontGroup-&gt;GetFamilies());
</pre>
<pre class="eval">Index: nsXULElement.h
===================================================================
RCS file: /cvsroot/mozilla/content/xul/content/src/nsXULElement.h,v
retrieving revision 1.233
diff -u -r1.233 nsXULElement.h
--- nsXULElement.h	26 Dec 2006 17:47:49 -0000	1.233
+++ nsXULElement.h	30 Dec 2006 16:01:33 -0000
@@ -720,6 +720,7 @@
     private:
         nsRefPtr&lt;nsXULElement&gt; mElement;
     };
+    friend class nsScriptEventHandlerOwnerTearoff;
 };

 #endif // nsXULElement_h__
</pre>
<pre class="eval">Index: gfxWindowsFonts.h
===================================================================
RCS file: /cvsroot/mozilla/gfx/thebes/public/gfxWindowsFonts.h,v
retrieving revision 1.62
diff -u -r1.62 gfxWindowsFonts.h
--- gfxWindowsFonts.h	12 Jul 2007 18:14:59 -0000	1.62
+++ gfxWindowsFonts.h	13 Jul 2007 11:09:26 -0000
@@ -242,10 +242,11 @@

 class gfxSparseBitSet {
-private:
+public:
     enum { BLOCK_SIZE = 32 };
     enum { BLOCK_SIZE_BITS = BLOCK_SIZE * 8 };

+private:
     struct Block {
         Block(unsigned char memsetValue = 0) { memset(mBits, memsetValue, BLOCK_SIZE); }
         PRUint8 mBits[BLOCK_SIZE];
</pre>
<ul>
  <li>VC6 only allows a simple type name in a virtual method override. Furthermore it confuses inner classes that have the same simple name. Generated Query Interface required these changes but it has since been backed out:</li>
</ul>
<pre class="eval">Index: nsHTMLAnchorElement.h
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsHTMLAnchorElement.h,v
retrieving revision 1.1
diff -u -r1.1 nsHTMLAnchorElement.h
--- nsHTMLAnchorElement.h	25 Jan 2008 17:14:51 -0000	1.1
+++ nsHTMLAnchorElement.h	13 Feb 2008 12:12:48 -0000
@@ -54,6 +54,8 @@
   nsHTMLAnchorElement(nsINodeInfo *aNodeInfo);
   virtual ~nsHTMLAnchorElement();

+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_USING(nsHTMLAnchorElement, nsGenericElement)
+
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED

Index: nsHTMLDivElement.h
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsHTMLDivElement.h,v
retrieving revision 1.1
diff -u -r1.1 nsHTMLDivElement.h
--- nsHTMLDivElement.h	25 Jan 2008 17:14:51 -0000	1.1
+++ nsHTMLDivElement.h	13 Feb 2008 12:12:48 -0000
@@ -48,6 +48,8 @@
   nsHTMLDivElement(nsINodeInfo *aNodeInfo);
   virtual ~nsHTMLDivElement();

+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_USING(nsHTMLDivElement, nsGenericElement)
+
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED

Index: nsHTMLFrameElement.h
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsHTMLFrameElement.h,v
retrieving revision 1.1
diff -u -r1.1 nsHTMLFrameElement.h
--- nsHTMLFrameElement.h	25 Jan 2008 17:14:51 -0000	1.1
+++ nsHTMLFrameElement.h	13 Feb 2008 12:12:50 -0000
@@ -48,6 +48,8 @@
   nsHTMLFrameElement(nsINodeInfo *aNodeInfo);
   virtual ~nsHTMLFrameElement();

+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_USING(nsHTMLFrameElement, nsGenericElement)
+
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED

Index: nsHTMLFrameSetElement.h
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsHTMLFrameSetElement.h,v
retrieving revision 1.1
diff -u -r1.1 nsHTMLFrameSetElement.h
--- nsHTMLFrameSetElement.h	25 Jan 2008 17:14:51 -0000	1.1
+++ nsHTMLFrameSetElement.h	13 Feb 2008 12:12:50 -0000
@@ -50,6 +50,8 @@
   nsHTMLFrameSetElement(nsINodeInfo *aNodeInfo);
   virtual ~nsHTMLFrameSetElement();

+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_USING(nsHTMLFrameSetElement, nsGenericElement)
+
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED

Index: nsHTMLIFrameElement.h
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsHTMLIFrameElement.h,v
retrieving revision 1.1
diff -u -r1.1 nsHTMLIFrameElement.h
--- nsHTMLIFrameElement.h	25 Jan 2008 17:14:51 -0000	1.1
+++ nsHTMLIFrameElement.h	13 Feb 2008 12:12:50 -0000
@@ -49,6 +49,8 @@
   nsHTMLIFrameElement(nsINodeInfo *aNodeInfo);
   virtual ~nsHTMLIFrameElement();

+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_USING(nsHTMLIFrameElement, nsGenericElement)
+
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED

Index: nsHTMLSpanElement.h
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsHTMLSpanElement.h,v
retrieving revision 1.1
diff -u -r1.1 nsHTMLSpanElement.h
--- nsHTMLSpanElement.h	25 Jan 2008 17:14:51 -0000	1.1
+++ nsHTMLSpanElement.h	13 Feb 2008 12:12:54 -0000
@@ -48,6 +48,8 @@
   nsHTMLSpanElement(nsINodeInfo *aNodeInfo);
   virtual ~nsHTMLSpanElement();

+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_USING(nsHTMLSpanElement, nsGenericElement)
+
   // nsISupports
   NS_DECL_ISUPPORTS_INHERITED

</pre>
<ul>
  <li>VC6 incorrectly thinks that references to static members of multiply derived classes are ambiguous. However the nsAccessibleEventData code needs to port to the branch so the patch has since been applied on trunk.</li>
</ul>
<pre class="eval">Index: nsAccessibleEventData.cpp
===================================================================
RCS file: /cvsroot/mozilla/accessible/src/base/nsAccessibleEventData.cpp,v
retrieving revision 1.8
diff -u -r1.8 nsAccessibleEventData.cpp
--- nsAccessibleEventData.cpp	13 Apr 2007 06:03:31 -0000	1.8
+++ nsAccessibleEventData.cpp	14 Apr 2007 09:35:36 -0000
@@ -123,7 +123,7 @@
   nsAccStateChangeEvent(nsIAccessible *aAccessible,
                         PRUint32 aState, PRBool aIsExtraState,
                         PRBool aIsEnabled):
-  nsAccEvent(nsIAccessibleEvent::EVENT_STATE_CHANGE, aAccessible, nsnull),
+  nsAccEvent(::nsIAccessibleEvent::EVENT_STATE_CHANGE, aAccessible, nsnull),
   mState(aState), mIsExtraState(aIsExtraState), mIsEnabled(aIsEnabled)
 {
 }
</pre>
<ul>
  <li>VC6 doesn't allow const members of a POD type, and thus failed to compile the initializers for UnitInfo. Fortunately this also confuses the VC7.1 optimizer which is why this patch has since been applied:</li>
</ul>
<pre class="eval">Index: nsCSSParser.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/style/nsCSSParser.cpp,v
retrieving revision 3.331
diff -u -r3.331 nsCSSParser.cpp
--- nsCSSParser.cpp	12 Dec 2006 15:34:43 -0000	3.331
+++ nsCSSParser.cpp	13 Dec 2006 16:36:41 -0000
@@ -3567,8 +3567,8 @@

 struct UnitInfo {
-  const char name[5];  // needs to be long enough for the longest unit, with
-                       // terminating null.
+  char name[5];  // needs to be long enough for the longest unit, with
+                 // terminating null.
   PRUint32 length;
   nsCSSUnit unit;
   PRInt32 type;
</pre>
<ul>
  <li>VC6 was unable to compile an nsTArray&lt;nsCOMPtr&lt;nsIFile&gt; &gt; because it appeared to be confused by the use of unions inside the various nsCOMPtr methods. This was only a problem when compiling tests with --enable-debug. However the use of unions was itself an unsafe fix to a strict aliasing fix and this patch has now been applied as the correct fix:</li>
</ul>
<pre class="eval">Index: nsCOMPtr.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/glue/nsCOMPtr.cpp,v
retrieving revision 1&amp;
diff -u -r1&amp; nsCOMPtr.cpp
--- nsCOMPtr.cpp	23 Nov 2006 16:10:43 -0000	1&amp;
+++ nsCOMPtr.cpp	31 Dec 2006 10:46:55 -0000
@@ -92,64 +92,64 @@
 void
 nsCOMPtr_base::assign_from_qi( const nsQueryInterface qi, const nsIID&amp; iid )
   {
-    union { nsISupports *mSupports; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( qi(iid, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mSupports = 0;
-    assign_assuming_AddRef(newRawPtr.mSupports);
+    void* newRawPtr;
+    if ( NS_FAILED( qi(iid, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(nsISupports*, newRawPtr));
   }

 void
 nsCOMPtr_base::assign_from_qi_with_error( const nsQueryInterfaceWithError&amp; qi, const nsIID&amp; iid )
   {
-    union { nsISupports* mSupports; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( qi(iid, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mSupports = 0;
-    assign_assuming_AddRef(newRawPtr.mSupports);
+    void* newRawPtr;
+    if ( NS_FAILED( qi(iid, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(nsISupports*, newRawPtr));
   }

 void
 nsCOMPtr_base::assign_from_gs_cid( const nsGetServiceByCID gs, const nsIID&amp; iid )
   {
-    union { nsISupports* mSupports; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(iid, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mSupports = 0;
-    assign_assuming_AddRef(newRawPtr.mSupports);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(iid, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(nsISupports*, newRawPtr));
   }

 void
 nsCOMPtr_base::assign_from_gs_cid_with_error( const nsGetServiceByCIDWithError&amp; gs, const nsIID&amp; iid )
   {
-    union { nsISupports* mSupports; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(iid, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mSupports = 0;
-    assign_assuming_AddRef(newRawPtr.mSupports);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(iid, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(nsISupports*, newRawPtr));
   }

 void
 nsCOMPtr_base::assign_from_gs_contractid( const nsGetServiceByContractID gs, const nsIID&amp; iid )
   {
-    union { nsISupports* mSupports; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(iid, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mSupports = 0;
-    assign_assuming_AddRef(newRawPtr.mSupports);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(iid, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(nsISupports*, newRawPtr));
   }

 void
 nsCOMPtr_base::assign_from_gs_contractid_with_error( const nsGetServiceByContractIDWithError&amp; gs, const nsIID&amp; iid )
   {
-    union { nsISupports* mSupports; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(iid, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mSupports = 0;
-    assign_assuming_AddRef(newRawPtr.mSupports);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(iid, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(nsISupports*, newRawPtr));
   }

 void
 nsCOMPtr_base::assign_from_helper( const nsCOMPtr_helper&amp; helper, const nsIID&amp; iid )
   {
-    union { nsISupports* mSupports; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( helper(iid, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mSupports = 0;
-    assign_assuming_AddRef(newRawPtr.mSupports);
+    void* newRawPtr;
+    if ( NS_FAILED( helper(iid, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(nsISupports*, newRawPtr));
   }

 void**
Index: nsCOMPtr.h
===================================================================
RCS file: /cvsroot/mozilla/xpcom/glue/nsCOMPtr.h,v
retrieving revision 1.125
diff -u -r1.125 nsCOMPtr.h
--- nsCOMPtr.h	23 Nov 2006 16:10:43 -0000	1.125
+++ nsCOMPtr.h	31 Dec 2006 10:46:57 -0000
@@ -1240,70 +1240,70 @@
 void
 nsCOMPtr&lt;T&gt;::assign_from_qi( const nsQueryInterface qi, const nsIID&amp; aIID )
   {
-    union { T* mT; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( qi(aIID, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mT = 0;
-    assign_assuming_AddRef(newRawPtr.mT);
+    void* newRawPtr;
+    if ( NS_FAILED( qi(aIID, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(T*, newRawPtr));
   }

 template &lt;class T&gt;
 void
 nsCOMPtr&lt;T&gt;::assign_from_qi_with_error( const nsQueryInterfaceWithError&amp; qi, const nsIID&amp; aIID )
   {
-    union { T* mT; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( qi(aIID, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mT = 0;
-    assign_assuming_AddRef(newRawPtr.mT);
+    void* newRawPtr;
+    if ( NS_FAILED( qi(aIID, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(T*, newRawPtr));
   }

 template &lt;class T&gt;
 void
 nsCOMPtr&lt;T&gt;::assign_from_gs_cid( const nsGetServiceByCID gs, const nsIID&amp; aIID )
   {
-    union { T* mT; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(aIID, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mT = 0;
-    assign_assuming_AddRef(newRawPtr.mT);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(aIID, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(T*, newRawPtr));
   }

 template &lt;class T&gt;
 void
 nsCOMPtr&lt;T&gt;::assign_from_gs_cid_with_error( const nsGetServiceByCIDWithError&amp; gs, const nsIID&amp; aIID )
   {
-    union { T* mT; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(aIID, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mT = 0;
-    assign_assuming_AddRef(newRawPtr.mT);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(aIID, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(T*, newRawPtr));
   }

 template &lt;class T&gt;
 void
 nsCOMPtr&lt;T&gt;::assign_from_gs_contractid( const nsGetServiceByContractID gs, const nsIID&amp; aIID )
   {
-    union { T* mT; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(aIID, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mT = 0;
-    assign_assuming_AddRef(newRawPtr.mT);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(aIID, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(T*, newRawPtr));
   }

 template &lt;class T&gt;
 void
 nsCOMPtr&lt;T&gt;::assign_from_gs_contractid_with_error( const nsGetServiceByContractIDWithError&amp; gs, const nsIID&amp; aIID )
   {
-    union { T* mT; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( gs(aIID, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mT = 0;
-    assign_assuming_AddRef(newRawPtr.mT);
+    void* newRawPtr;
+    if ( NS_FAILED( gs(aIID, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(T*, newRawPtr));
   }

 template &lt;class T&gt;
 void
 nsCOMPtr&lt;T&gt;::assign_from_helper( const nsCOMPtr_helper&amp; helper, const nsIID&amp; aIID )
   {
-    union { T* mT; void *mVoid; } newRawPtr;
-    if ( NS_FAILED( helper(aIID, &amp;newRawPtr.mVoid) ) )
-      newRawPtr.mT = 0;
-    assign_assuming_AddRef(newRawPtr.mT);
+    void* newRawPtr;
+    if ( NS_FAILED( helper(aIID, &amp;newRawPtr) ) )
+      newRawPtr = 0;
+    assign_assuming_AddRef(NS_STATIC_CAST(T*, newRawPtr));
   }

 template &lt;class T&gt;
@@ -1311,9 +1311,7 @@
 nsCOMPtr&lt;T&gt;::begin_assignment()
   {
     assign_assuming_AddRef(0);
-    union { T** mT; void** mVoid; } result;
-    result.mT = &amp;mRawPtr;
-    return result.mVoid;
+    return NS_REINTERPRET_CAST(void**, &amp;mRawPtr);
   }
 #endif

</pre>
<ul>
  <li>VC6 won't let you return a value from a void function. However the nsXFormsContextContainer code needs to port to the branch so the first patch has since been applied on trunk, while the gfxWindowsFonts change has since been obsoleted by further changes to windows font handling:</li>
</ul>
<pre class="eval">Index: nsXFormsContextContainer.cpp
===================================================================
RCS file: /cvsroot/mozilla/extensions/xforms/nsXFormsContextContainer.cpp,v
retrieving revision 1.25
diff -u -r1.25 nsXFormsContextContainer.cpp
--- nsXFormsContextContainer.cpp	7 Mar 2007 17:46:57 -0000	1.25
+++ nsXFormsContextContainer.cpp	9 Mar 2007 13:18:26 -0000
@@ -377,7 +377,8 @@
     state = eType_GeneratedContent;
   }

-  return nsXFormsControlStub::SetRepeatState(state);
+  nsXFormsControlStub::SetRepeatState(state);
+  return;
 }

 // Factory
</pre>
<pre class="eval">Index: gfxWindowsFonts.cpp
===================================================================
RCS file: /cvsroot/mozilla/gfx/thebes/src/gfxWindowsFonts.cpp,v
retrieving revision 1.85
diff -u -r1.85 gfxWindowsFonts.cpp
--- gfxWindowsFonts.cpp	9 Feb 2007 02:51:06 -0000	1.85
+++ gfxWindowsFonts.cpp	12 Feb 2007 16:18:31 -0000
@@ -631,7 +631,7 @@
     NS_ASSERTION(aStart == 0 &amp;&amp; aLength == mLength, "Can't handle substrings");
     SetupSpacingFromProvider(aBreakProvider);
     gfxPoint pt(aPt.x/mAppUnitsPerDevUnit, aPt.y/mAppUnitsPerDevUnit);
-    return mInner.Draw(mContext, pt);
+    mInner.Draw(mContext, pt);
 }

 gfxFloat
</pre>
<ul>
  <li>VC6 generates the incorrect symbols for classes that have been incorrectly forward-declared even if they are later defined. This has since been fixed for correctness reasons using this patch:</li>
</ul>
<pre class="eval">Index: nsSVGUtils.h
===================================================================
RCS file: /cvsroot/mozilla/layout/svg/base/src/nsSVGUtils.h,v
retrieving revision 1.44
diff -p -u -d -r1.44 nsSVGUtils.h
--- nsSVGUtils.h	5 Feb 2007 20:04:17 -0000	1.44
+++ nsSVGUtils.h	11 Feb 2007 11:31:34 -0000
@@ -71,7 +71,7 @@ class gfxContext;
 class gfxASurface;
 class nsIRenderingContext;
 struct gfxRect;
-class gfxMatrix;
+struct gfxMatrix;

 #ifndef M_PI
 #define M_PI 3.14159265358979323846
</pre>
<ul>
  <li>VC6 only allows array-style initializers for POD types, so it fails to compile the initializers for EudoraDefaultLabels, nsARIAMap or SuspectClosure. The indentation of the nsEudoraImport code has since been changed; the type of nsARIAMap has changed, while the xpcwrappednativescope code has been changed so that it works with the Solaris compiler.</li>
</ul>
<pre class="eval">Index: nsEudoraImport.cpp
===================================================================
RCS file: /cvsroot/mozilla/mailnews/import/eudora/src/nsEudoraImport.cpp,v
retrieving revision 1.44
diff -u -r1.44 nsEudoraImport.cpp
--- nsEudoraImport.cpp	8 May 2007 23:07:19 -0000	1.44
+++ nsEudoraImport.cpp	11 May 2007 14:10:00 -0000
@@ -376,7 +376,7 @@
 		struct EudoraDefaultLabels
 		{
 			char *		key;
-			nsString	tag;
+			char *		tag;
 			char *		color;
 		};

@@ -387,20 +387,20 @@
 		// Use one dummy entry for now as a placeholder to keep the Mac code valid,
 		// until we enter actual reasonable defaults for Mac builds.
 		EudoraDefaultLabels		defaultEudoraLabels[1] =
-										{ "eudoralabel1", NS_LITERAL_STRING("Label 1"), "#FF6600" };
+										{ "eudoralabel1", "Label 1", "#FF6600" };
 #else
 		// These aren't the actual default Windows Eudora colors. Rather they're the closest
 		// equivalents that I could find that Thunderbird supports. When importing actual
 		// label settings, we'll need to map Eudora colors to ones that are supported.
 		#define		kNumEudoraLabels		7
 		EudoraDefaultLabels		defaultEudoraLabels[kNumEudoraLabels] =
-										{ "eudoralabel1", NS_LITERAL_STRING("Label 1"), "#FF6600",
-										  "eudoralabel2", NS_LITERAL_STRING("Label 2"), "#FF0000",
-										  "eudoralabel3", NS_LITERAL_STRING("Label 3"), "#CC66CC",
-										  "eudoralabel4", NS_LITERAL_STRING("Label 4"), "#3366FF",
-										  "eudoralabel5", NS_LITERAL_STRING("Label 5"), "#000099",
-										  "eudoralabel6", NS_LITERAL_STRING("Label 6"), "#009900",
-										  "eudoralabel7", NS_LITERAL_STRING("Label 7"), "#663333" };
+										{ "eudoralabel1", "Label 1", "#FF6600",
+										  "eudoralabel2", "Label 2", "#FF0000",
+										  "eudoralabel3", "Label 3", "#CC66CC",
+										  "eudoralabel4", "Label 4", "#3366FF",
+										  "eudoralabel5", "Label 5", "#000099",
+										  "eudoralabel6", "Label 6", "#009900",
+										  "eudoralabel7", "Label 7", "#663333" };
 #endif

 		nsCString			eudoraKey;
@@ -412,7 +412,7 @@
 			rv = pTagService-&gt;GetTagForKey(eudoraKey, eudoraTag);
 			if ( NS_FAILED(rv) || eudoraTag.IsEmpty() ) {
 				eudoraColor = defaultEudoraLabels[i].color;
-				rv = pTagService-&gt;AddTagForKey( eudoraKey, defaultEudoraLabels[i].tag, eudoraColor, EmptyCString() );
+				rv = pTagService-&gt;AddTagForKey( eudoraKey, NS_ConvertASCIItoUTF16(defaultEudoraLabels[i].tag), eudoraColor, EmptyCString() );
 			}
 		}
 	}
</pre>
<pre class="eval">Index: nsARIAMap.cpp
===================================================================
RCS file: /cvsroot/mozilla/accessible/src/base/nsARIAMap.cpp,v
retrieving revision 1.16
diff -u -r1.16 nsARIAMap.cpp
--- nsARIAMap.cpp	25 Sep 2007 01:56:02 -0000	1.16
+++ nsARIAMap.cpp	27 Sep 2007 06:25:59 -0000
@@ -68,7 +68,7 @@
  *    banner, contentinfo, main, navigation, note, search, secondary, seealso, breadcrumbs
  */

-static const nsStateMapEntry kEndEntry = {eAria_none, 0, 0};  // To fill in array of state mappings
+#define kEndEntry {eAria_none, 0, 0}  // To fill in array of state mappings

 nsRoleMapEntry nsARIAMap::gWAIRoleMap[] =
 {
</pre>
<pre class="eval">Index: xpcwrappednativescope.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcwrappednativescope.cpp,v
retrieving revision 1.59
diff -u -r1.59 xpcwrappednativescope.cpp
--- xpcwrappednativescope.cpp	1 Nov 2007 22:51:58 -0000	1.59
+++ xpcwrappednativescope.cpp	2 Nov 2007 13:47:12 -0000
@@ -312,7 +312,7 @@
 struct SuspectClosure
 {
     JSContext* cx;
-    nsCycleCollectionTraversalCallback&amp; cb;
+    nsCycleCollectionTraversalCallback* cb;
 };

 JS_STATIC_DLL_CALLBACK(JSDHashOperator)
@@ -333,9 +333,9 @@
             return JS_DHASH_NEXT;
 #endif

-        closure-&gt;cb.NoteRoot(nsIProgrammingLanguage::JAVASCRIPT,
-                             wrapper-&gt;GetFlatJSObject(),
-                             nsXPConnect::GetXPConnect());
+        closure-&gt;cb-&gt;NoteRoot(nsIProgrammingLanguage::JAVASCRIPT,
+                              wrapper-&gt;GetFlatJSObject(),
+                              nsXPConnect::GetXPConnect());
     }

     return JS_DHASH_NEXT;
@@ -348,7 +348,7 @@
 {
     XPCAutoLock lock(rt-&gt;GetMapLock());

-    SuspectClosure closure = { cx, cb };
+    SuspectClosure closure = { cx, &amp;cb };
     for(XPCWrappedNativeScope* cur = gScopes; cur; cur = cur-&gt;mNext)
     {
         cur-&gt;mWrappedNativeMap-&gt;Enumerate(WrappedNativeSuspecter, &amp;closure);
</pre>
<ul>
  <li>VC6 uses old-style scoping rules for variables declared in for loops, which makes it unable to compile several functions. However the BasicTableLayoutStrategy loops have been altered, the nsSVGElement changes have since been applied independently while some of the other loops have since been moved or removed:</li>
</ul>
<pre class="eval">Index: BasicTableLayoutStrategy.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/tables/BasicTableLayoutStrategy.cpp,v
retrieving revision 3.240
diff -u -r3.240 BasicTableLayoutStrategy.cpp
--- BasicTableLayoutStrategy.cpp	26 Dec 2006 17:47:52 -0000	3.240
+++ BasicTableLayoutStrategy.cpp	1 Jan 2007 11:00:49 -0000
@@ -566,7 +566,8 @@

     // border-spacing isn't part of the basis for percentages.
     nscoord subtract = spacing;
-    for (PRInt32 col = 0; col &lt; colCount; ++col) {
+    PRInt32 col;
+    for (col = 0; col &lt; colCount; ++col) {
         if (mTableFrame-&gt;GetNumCellsOriginatingInCol(col)) {
             subtract += spacing;
         }
@@ -628,7 +629,6 @@
             total_fixed_pref = 0;
     float total_pct = 0.0f; // 0.0f to 1.0f

-    PRInt32 col;
     for (col = 0; col &lt; colCount; ++col) {
         nsTableColFrame *colFrame = mTableFrame-&gt;GetColFrame(col);
         if (!colFrame) {
</pre>
<pre class="eval">Index: nsCycleCollector.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/base/nsCycleCollector.cpp,v
retrieving revision 1.24
diff -u -r1.24 nsCycleCollector.cpp
--- nsCycleCollector.cpp	19 Mar 2007 23:21:31 -0000	1.24
+++ nsCycleCollector.cpp	20 Mar 2007 09:02:14 -0000
@@ -1385,7 +1385,8 @@

     mGraph.Clear();

-    for (PRUint32 i = 0; i &lt; nsIProgrammingLanguage::MAX+1; ++i) {
+    PRUint32 i;
+    for (i = 0; i &lt; nsIProgrammingLanguage::MAX+1; ++i) {
         delete mBufs[i];
         mBufs[i] = NULL;
     }
@@ -1393,7 +1394,7 @@
     delete mRuntimes[nsIProgrammingLanguage::CPLUSPLUS];
     mRuntimes[nsIProgrammingLanguage::CPLUSPLUS] = NULL;

-    for (PRUint32 i = 0; i &lt; nsIProgrammingLanguage::MAX+1; ++i) {
+    for (i = 0; i &lt; nsIProgrammingLanguage::MAX+1; ++i) {
         mRuntimes[i] = NULL;
     }
 }
@@ -1860,7 +1863,7 @@

     mScanInProgress = PR_FALSE;

-    for (int i = 0; i &lt; mBufs[0]-&gt;GetSize(); ++i) {
+    for (i = 0; i &lt; mBufs[0]-&gt;GetSize(); ++i) {
         nsISupports *s = NS_STATIC_CAST(nsISupports *, mBufs[0]-&gt;ObjectAt(i));
         s = canonicalize(s);
         explainWalker(mGraph, mRuntimes).Walk(s);
</pre>
<pre class="eval">Index: nsCycleCollector.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/base/nsCycleCollector.cpp,v
retrieving revision 1.34
diff -u -r1.34 nsCycleCollector.cpp
--- nsCycleCollector.cpp	25 Apr 2007 21:12:11 -0000	1.34
+++ nsCycleCollector.cpp	26 Apr 2007 22:09:05 -0000
@@ -2064,7 +2064,8 @@
 #ifdef COLLECT_TIME_DEBUG
         now = PR_Now();
 #endif
-        for (PRUint32 i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
+        PRUint32 i;
+        for (i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
             if (mRuntimes[i])
                 mRuntimes[i]-&gt;BeginCycleCollection();
         }
@@ -2132,7 +2133,8 @@
 #ifdef COLLECT_TIME_DEBUG
     PRTime now = PR_Now();
 #endif
-    for (PRUint32 i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
+    PRUint32 i;
+    for (i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
         if (mRuntimes[i])
             mRuntimes[i]-&gt;BeginCycleCollection(builder);
     }
@@ -2179,7 +2181,7 @@
 #endif
         }

-        for (PRUint32 i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
+        for (i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
             if (mRuntimes[i])
                 mRuntimes[i]-&gt;FinishCycleCollection();
         }
@@ -2228,7 +2230,7 @@
         mStats.Dump();
 #endif

-    for (PRUint32 i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
+    for (i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
         if (mRuntimes[i])
             mRuntimes[i]-&gt;FinishCycleCollection();
     }
@@ -2255,7 +2257,7 @@

     mBuf.Empty();

-    for (PRUint32 i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
+    for (i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
         if (mRuntimes[i]) {
             mRuntimes[i]-&gt;BeginCycleCollection();
             mRuntimes[i]-&gt;SuspectExtraPointers();
@@ -2474,7 +2476,7 @@

     mCollectionInProgress = PR_FALSE;

-    for (PRUint32 i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
+    for (i = 0; i &lt;= nsIProgrammingLanguage::MAX; ++i) {
         if (mRuntimes[i])
             mRuntimes[i]-&gt;FinishCycleCollection();
     }
</pre>
<pre class="eval">Index: nsCSSRendering.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/base/nsCSSRendering.cpp,v
retrieving revision 3.312
diff -u -r3.312 nsCSSRendering.cpp
--- nsCSSRendering.cpp	8 May 2007 17:40:08 -0000	3.312
+++ nsCSSRendering.cpp	10 May 2007 08:21:41 -0000
@@ -2096,7 +2096,8 @@
   aBorderStyle.mBorderRadius.GetLeft(bordStyleRadius[3]);     //bottomleft

   // convert percentage values
-  for(int i = 0; i &lt; 4; i++) {
+  int i;
+  for (i = 0; i &lt; 4; i++) {
     borderRadii[i] = 0;

     switch (bordStyleRadius[i].GetUnit()) {
@@ -2332,7 +2333,7 @@
   // (since all 4 are identical) and not set any clip so that
   // DrawBorderSides draws the entire border in one go.
   int numSides = doSeparateSides ? 4 : 1;
-  for (int i = 0; i &lt; numSides; i++) {
+  for (i = 0; i &lt; numSides; i++) {
     PRUint8 side = sideOrder[i];

     // skip this side if it's, well, skipped
@@ -2443,7 +2444,8 @@
   aOutlineStyle.mOutlineRadius.GetLeft(bordStyleRadius[3]);     //bottomleft

   // convert percentage values
-  for (int i = 0; i &lt; 4; i++) {
+  int i;
+  for (i = 0; i &lt; 4; i++) {
     borderRadii[i] = 0;

     switch (bordStyleRadius[i].GetUnit()) {
@@ -2615,7 +2617,7 @@
   static PRUint8 sideOrder[] = { NS_SIDE_BOTTOM, NS_SIDE_LEFT, NS_SIDE_TOP, NS_SIDE_RIGHT };

   int numSides = doSeparateSides ? 4 : 1;
-  for (int i = 0; i &lt; numSides; i++) {
+  for (i = 0; i &lt; numSides; i++) {
     PRUint8 side = sideOrder[i];

     // skip this side if it's, well, skipped
</pre>
<pre class="eval">Index: mozStorageStatement.cpp
===================================================================
RCS file: /cvsroot/mozilla/storage/src/mozStorageStatement.cpp,v
retrieving revision 1.17
diff -u -r1.17 mozStorageStatement.cpp
--- mozStorageStatement.cpp	18 Jun 2007 23:42:23 -0000	1.17
+++ mozStorageStatement.cpp	20 Jun 2007 16:33:54 -0000
@@ -252,8 +252,8 @@
         return NS_ERROR_OUT_OF_MEMORY;
     }

-    for (int i = 0; i &lt; size; i++)
-        (*aIndexes)[i] = idxs[i];
+    for (int j = 0; j &lt; size; j++)
+        (*aIndexes)[j] = idxs[j];

     delete[] idxs;

</pre>
<pre class="eval">Index: nsSVGElement.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/svg/content/src/nsSVGElement.cpp,v
retrieving revision 1.135
diff -u -r1.135 nsSVGElement.cpp
--- nsSVGElement.cpp	26 Sep 2007 09:22:08 -0000	1.135
+++ nsSVGElement.cpp	27 Sep 2007 06:26:00 -0000
@@ -259,7 +259,9 @@

     // Check for nsSVGLength2 attribute
     LengthAttributesInfo lengthInfo = GetLengthInfo();
-    for (PRUint32 i = 0; i &lt; lengthInfo.mLengthCount &amp;&amp; !foundMatch; i++) {
+
+    PRUint32 i = 0;
+    for (i = 0; i &lt; lengthInfo.mLengthCount &amp;&amp; !foundMatch; i++) {
       if (aAttribute == *lengthInfo.mLengthInfo[i].mName) {
         rv = lengthInfo.mLengths[i].SetBaseValueString(aValue, this, PR_FALSE);
         foundMatch = PR_TRUE;
@@ -268,7 +270,7 @@

     // Check for nsSVGNumber2 attribute
     NumberAttributesInfo numberInfo = GetNumberInfo();
-    for (PRUint32 i = 0; i &lt; numberInfo.mNumberCount &amp;&amp; !foundMatch; i++) {
+    for (i = 0; i &lt; numberInfo.mNumberCount &amp;&amp; !foundMatch; i++) {
       if (aAttribute == *numberInfo.mNumberInfo[i].mName) {
         rv = numberInfo.mNumbers[i].SetBaseValueString(aValue, this, PR_FALSE);
         foundMatch = PR_TRUE;
@@ -277,7 +279,7 @@

     // Check for nsSVGInteger attribute
     IntegerAttributesInfo integerInfo = GetIntegerInfo();
-    for (PRUint32 i = 0; i &lt; integerInfo.mIntegerCount &amp;&amp; !foundMatch; i++) {
+    for (i = 0; i &lt; integerInfo.mIntegerCount &amp;&amp; !foundMatch; i++) {
       if (aAttribute == *integerInfo.mIntegerInfo[i].mName) {
         rv = integerInfo.mIntegers[i].SetBaseValueString(aValue, this, PR_FALSE);
         foundMatch = PR_TRUE;
@@ -286,7 +288,7 @@

     // Check for nsSVGBoolean attribute
     BooleanAttributesInfo booleanInfo = GetBooleanInfo();
-    for (PRUint32 i = 0; i &lt; booleanInfo.mBooleanCount &amp;&amp; !foundMatch; i++) {
+    for (i = 0; i &lt; booleanInfo.mBooleanCount &amp;&amp; !foundMatch; i++) {
       if (aAttribute == *booleanInfo.mBooleanInfo[i].mName) {
         rv = booleanInfo.mBooleans[i].SetBaseValueString(aValue, this, PR_FALSE);
         foundMatch = PR_TRUE;
@@ -295,7 +297,7 @@

     // Check for nsSVGEnum attribute
     EnumAttributesInfo enumInfo = GetEnumInfo();
-    for (PRUint32 i = 0; i &lt; enumInfo.mEnumCount &amp;&amp; !foundMatch; i++) {
+    for (i = 0; i &lt; enumInfo.mEnumCount &amp;&amp; !foundMatch; i++) {
       if (aAttribute == *enumInfo.mEnumInfo[i].mName) {
         rv = enumInfo.mEnums[i].SetBaseValueString(aValue, this, PR_FALSE);
         foundMatch = PR_TRUE;
</pre>
<pre class="eval">Index: xpcjsruntime.cpp
===================================================================
RCS file: /cvsroot/mozilla/js/src/xpconnect/src/xpcjsruntime.cpp,v
retrieving revision 1.55
diff -u -r1.55 xpcjsruntime.cpp
--- xpcjsruntime.cpp	8 Jul 2007 07:08:29 -0000	1.55
+++ xpcjsruntime.cpp	10 Jul 2007 10:48:17 -0000
@@ -277,13 +277,14 @@

     XPCWrappedNativeScope::TraceJS(trc, self);

-    for (XPCRootSetElem *e = self-&gt;mVariantRoots; e ; e = e-&gt;GetNextRoot())
+    XPCRootSetElem *e;
+    for (e = self-&gt;mVariantRoots; e ; e = e-&gt;GetNextRoot())
         static_cast&lt;XPCTraceableVariant*&gt;(e)-&gt;TraceJS(trc);

-    for (XPCRootSetElem *e = self-&gt;mWrappedJSRoots; e ; e = e-&gt;GetNextRoot())
+    for (e = self-&gt;mWrappedJSRoots; e ; e = e-&gt;GetNextRoot())
         static_cast&lt;nsXPCWrappedJS*&gt;(e)-&gt;TraceJS(trc);

-    for (XPCRootSetElem *e = self-&gt;mObjectHolderRoots; e ; e = e-&gt;GetNextRoot())
+    for (e = self-&gt;mObjectHolderRoots; e ; e = e-&gt;GetNextRoot())
         static_cast&lt;XPCJSObjectHolder*&gt;(e)-&gt;TraceJS(trc);
 }

</pre>
<pre class="eval">Index: nsOfflineCacheUpdate.cpp
===================================================================
RCS file: /cvsroot/mozilla/uriloader/prefetch/nsOfflineCacheUpdate.cpp,v
retrieving revision 1.3
diff -u -r1.3 nsOfflineCacheUpdate.cpp
--- nsOfflineCacheUpdate.cpp	25 Jul 2007 06:31:28 -0000	1.3
+++ nsOfflineCacheUpdate.cpp	27 Jul 2007 10:04:08 -0000
@@ -631,12 +631,12 @@
             mWeakObservers.RemoveObjectAt(i--);
     }

-    for (PRInt32 i = 0; i &lt; mObservers.Count(); i++) {
-        observers.AppendObject(mObservers[i]);
+    for (PRInt32 j = 0; j &lt; mObservers.Count(); j++) {
+        observers.AppendObject(mObservers[j]);
     }

-    for (PRInt32 i = 0; i &lt; observers.Count(); i++) {
-        observers[i]-&gt;ItemCompleted(aItem);
+    for (PRInt32 k = 0; k &lt; observers.Count(); k++) {
+        observers[k]-&gt;ItemCompleted(aItem);
     }

     return NS_OK;
@@ -806,9 +806,9 @@
         }
     }

-    for (PRInt32 i = 0; i &lt; mObservers.Count(); i++) {
-        if (mObservers[i] == aObserver) {
-            mObservers.RemoveObjectAt(i);
+    for (PRInt32 j = 0; j &lt; mObservers.Count(); j++) {
+        if (mObservers[j] == aObserver) {
+            mObservers.RemoveObjectAt(j);
             return NS_OK;
         }
     }
</pre>
<pre class="eval">Index: gfxWindowsPlatform.cpp
===================================================================
RCS file: /cvsroot/mozilla/gfx/thebes/src/gfxWindowsPlatform.cpp,v
retrieving revision 1.41
diff -u -r1.41 gfxWindowsPlatform.cpp
--- gfxWindowsPlatform.cpp	19 Mar 2008 00:06:55 -0000	1.41
+++ gfxWindowsPlatform.cpp	19 Mar 2008 12:41:51 -0000
@@ -680,13 +680,13 @@
     PRUint8 direction = (weightDistance &gt;= 0) ? 1 : -1;

  WEIGHT_SELECTION:
-    for (PRUint8 i = baseWeight, k = 0; i &lt; 10 &amp;&amp; i &gt;= 1; i+=direction) {
-        if (weightList[i - 1]) {
+    for (PRUint8 j = baseWeight, k = 0; j &lt; 10 &amp;&amp; j &gt;= 1; j+=direction) {
+        if (weightList[j - 1]) {
             k++;
-            chosenWeight = i * 100;
+            chosenWeight = j * 100;
         }
         if (k &gt; abs(weightDistance)) {
-            chosenWeight = i * 100;
+            chosenWeight = j * 100;
             break;
         }
     }
@@ -705,8 +705,8 @@
     // If we end up with something like 900 here but only have 600,
     // search backwards until we find a match
     const PRUint32 index = (chosenWeight / 100) - 1;
-    for (PRInt32 j = index; j &gt;= 0; --j) {
-        if (matchFE = weightList[j])
+    for (i = index; i &gt;= 0; --i) {
+        if (matchFE = weightList[i])
             break;
     }

@@ -721,9 +721,10 @@
     }

+    PRInt8 i, k;
     PRInt8 matchBaseWeight = 0;
     PRInt8 direction = (baseWeight &gt; 5) ? 1 : -1;
-    for (PRInt8 i = baseWeight; ; i += direction) {
+    for (i = baseWeight; ; i += direction) {
         if (weightList[i]) {
             matchBaseWeight = i;
             break;
@@ -738,7 +739,7 @@
     nsRefPtr&lt;FontEntry&gt; matchFE;
     const PRInt8 absDistance = abs(weightDistance);
     direction = (weightDistance &gt;= 0) ? 1 : -1;
-    for (PRInt8 i = matchBaseWeight, k = 0; i &lt; 10 &amp;&amp; i &gt; 0; i += direction) {
+    for (i = matchBaseWeight, k = 0; i &lt; 10 &amp;&amp; i &gt; 0; i += direction) {
         if (weightList[i]) {
             matchFE = weightList[i];
             k++;
</pre>
<ul>
  <li>VC6 won't let you declare static const member variables. The indentation of this code has since been changed.</li>
</ul>
<pre class="eval">Index: nsEudoraMailbox.h
===================================================================
RCS file: /cvsroot/mozilla/mailnews/import/eudora/src/nsEudoraMailbox.h,v
retrieving revision 1.11
diff -u -r1.11 nsEudoraMailbox.h
--- nsEudoraMailbox.h	8 May 2007 23:07:19 -0000	1.11
+++ nsEudoraMailbox.h	11 May 2007 13:40:27 -0000
@@ -69,75 +69,77 @@
 	PRBool			HasEudoraLabel() { return (m_Label &gt; 0) &amp;&amp; (m_Label &lt;= 7); }
 	PRInt16			GetLabelNumber() { return HasEudoraLabel() ? m_Label : 0; }

-	// MesSummary flags (used with m_Flags)
-	static const PRUint16 MSF_ALT_SIGNATURE		= 0x0001;
-	static const PRUint16 MSF_USE_SIGNATURE		= 0x0002;
-	static const PRUint16 MSF_WORD_WRAP			= 0x0004;
-	static const PRUint16 MSF_TABS_IN_BODY		= 0x0008;
-	static const PRUint16 MSF_KEEP_COPIES		= 0x0010;
-	static const PRUint16 MSF_TEXT_AS_DOC		= 0x0020;
-	static const PRUint16 MSF_RETURN_RECEIPT	= 0x0040;
-	static const PRUint16 MSF_QUOTED_PRINTABLE	= 0x0080;
-	static const PRUint16 MSF_ENCODE0			= 0x0100;
-	static const PRUint16 MSF_ENCODE1			= 0x0200;
-	static const PRUint16 MSF_SHOW_ALL_HEADERS	= 0x0400;
-	static const PRUint16 MSF_SUB_PART			= 0x0800;
-	static const PRUint16 MSF_MAPI_MESSAGE		= 0x1000;
-	static const PRUint16 MSF_XRICH				= 0x2000;
-	static const PRUint16 MSF_READ_RECEIPT		= 0x4000;
-	static const PRUint16 MSF_HAS_ATTACHMENT	= 0x8000;
-	static const PRUint16 MSF_COMP_MOD_FLAGS	= 0x8FFF;
-	static const PRUint16 MSF_BINHEX			= 0;
-	static const PRUint16 MSF_MIME				= MSF_ENCODE0;
-	static const PRUint16 MSF_UUENCODE			= MSF_ENCODE1;
-
-	// MesSummary extended flags (used with m_FlagsEx)
-	static const PRUint16 MSFEX_AUTO_ATTACHED	= 0x0001;
-	static const PRUint16 MSFEX_HTML			= 0x0002;
-	static const PRUint16 MSFEX_MDN				= 0x0004;
-	static const PRUint16 MSFEX_MIME_ATTACHED	= 0x0008;
-	static const PRUint16 MSFEX_SEND_PLAIN		= 0x0010;
-	static const PRUint16 MSFEX_SEND_STYLED		= 0x0020;
-	static const PRUint16 MSFEX_FLOWED			= 0x0040;
-	static const PRUint16 MSFEX_INL_SIGNATURE	= 0x0080;
-	static const PRUint16 MSFEX_EMPTY_BODY		= 0x0100;
-
-	// MesSummary states
-	static const PRInt8 MS_UNREAD		= 0;
-	static const PRInt8 MS_READ			= 1;
-	static const PRInt8 MS_REPLIED		= 2;
-	static const PRInt8 MS_FORWARDED	= 3;
-	static const PRInt8 MS_REDIRECT		= 4;
-	static const PRInt8 MS_UNSENDABLE	= 5;
-	static const PRInt8 MS_SENDABLE		= 6;
-	static const PRInt8 MS_QUEUED		= 7;
-	static const PRInt8 MS_SENT			= 8;
-	static const PRInt8 MS_UNSENT		= 9;
-	static const PRInt8 MS_TIME_QUEUED	=10;
-	static const PRInt8 MS_SPOOLED		=11;
-	static const PRInt8 MS_RECOVERED	=12;
-
-	// MesSummary priorites
-	static const PRInt16 MSP_HIGHEST	= 1;
-	static const PRInt16 MSP_HIGH		= 2;
-	static const PRInt16 MSP_NORMAL		= 3;
-	static const PRInt16 MSP_LOW		= 4;
-	static const PRInt16 MSP_LOWEST		= 5;
-
-	// MesSummary Mood
-	static const PRInt8 MSM_MOOD_UNKNOWN	= 0;
-	static const PRInt8 MSM_MOOD_CLEAN		= 1;
-	static const PRInt8 MSM_MOOD_LOW		= 2;
-	static const PRInt8 MSM_MOOD_MEDIUM		= 3;
-	static const PRInt8 MSM_MOOD_HIGH		= 4;
-
-	// Imap message flags :
-	static const PRUint32 IMFLAGS_SEEN		= 0x00000001;
-	static const PRUint32 IMFLAGS_ANSWERED	= 0x00000002;
-	static const PRUint32 IMFLAGS_FLAGGED	= 0x00000004;
-	static const PRUint32 IMFLAGS_DELETED	= 0x00000008;
-	static const PRUint32 IMFLAGS_DRAFT		= 0x00000010;
-	static const PRUint32 IMFLAGS_RECENT	= 0x00000020;
+	enum {
+		// MesSummary flags (used with m_Flags)
+		MSF_ALT_SIGNATURE		= 0x0001,
+		MSF_USE_SIGNATURE		= 0x0002,
+		MSF_WORD_WRAP			= 0x0004,
+		MSF_TABS_IN_BODY		= 0x0008,
+		MSF_KEEP_COPIES			= 0x0010,
+		MSF_TEXT_AS_DOC			= 0x0020,
+		MSF_RETURN_RECEIPT		= 0x0040,
+		MSF_QUOTED_PRINTABLE	= 0x0080,
+		MSF_ENCODE0				= 0x0100,
+		MSF_ENCODE1				= 0x0200,
+		MSF_SHOW_ALL_HEADERS	= 0x0400,
+		MSF_SUB_PART			= 0x0800,
+		MSF_MAPI_MESSAGE		= 0x1000,
+		MSF_XRICH				= 0x2000,
+		MSF_READ_RECEIPT		= 0x4000,
+		MSF_HAS_ATTACHMENT		= 0x8000,
+		MSF_COMP_MOD_FLAGS		= 0x8FFF,
+		MSF_BINHEX				= 0,
+		MSF_MIME				= MSF_ENCODE0,
+		MSF_UUENCODE			= MSF_ENCODE1,
+
+		// MesSummary extended flags (used with m_FlagsEx)
+		MSFEX_AUTO_ATTACHED		= 0x0001,
+		MSFEX_HTML				= 0x0002,
+		MSFEX_MDN				= 0x0004,
+		MSFEX_MIME_ATTACHED		= 0x0008,
+		MSFEX_SEND_PLAIN		= 0x0010,
+		MSFEX_SEND_STYLED		= 0x0020,
+		MSFEX_FLOWED			= 0x0040,
+		MSFEX_INL_SIGNATURE		= 0x0080,
+		MSFEX_EMPTY_BODY		= 0x0100,
+
+		// MesSummary states
+		MS_UNREAD		= 0,
+		MS_READ			= 1,
+		MS_REPLIED		= 2,
+		MS_FORWARDED	= 3,
+		MS_REDIRECT		= 4,
+		MS_UNSENDABLE	= 5,
+		MS_SENDABLE		= 6,
+		MS_QUEUED		= 7,
+		MS_SENT			= 8,
+		MS_UNSENT		= 9,
+		MS_TIME_QUEUED	=10,
+		MS_SPOOLED		=11,
+		MS_RECOVERED	=12,
+
+		// MesSummary priorites
+		MSP_HIGHEST		= 1,
+		MSP_HIGH		= 2,
+		MSP_NORMAL		= 3,
+		MSP_LOW			= 4,
+		MSP_LOWEST		= 5,
+
+		// MesSummary Mood
+		MSM_MOOD_UNKNOWN	= 0,
+		MSM_MOOD_CLEAN		= 1,
+		MSM_MOOD_LOW		= 2,
+		MSM_MOOD_MEDIUM		= 3,
+		MSM_MOOD_HIGH		= 4,
+
+		// Imap message flags :
+		IMFLAGS_SEEN		= 0x00000001,
+		IMFLAGS_ANSWERED	= 0x00000002,
+		IMFLAGS_FLAGGED		= 0x00000004,
+		IMFLAGS_DELETED		= 0x00000008,
+		IMFLAGS_DRAFT		= 0x00000010,
+		IMFLAGS_RECENT		= 0x00000020
+	};

 	PRUint16		m_Flags;
 	PRUint16		m_FlagsEx;
</pre>
<ul>
  <li>VC6 won't let you compare pointers that have both different types and different constness. This patch has since been has since been obsoleted by further changes:</li>
</ul>
<pre class="eval">Index: nsGenericHTMLElement.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsGenericHTMLElement.cpp,v
retrieving revision 1.719
diff -u -r1.719 nsGenericHTMLElement.cpp
--- nsGenericHTMLElement.cpp	28 Jun 2007 02:48:16 -0000	1.719
+++ nsGenericHTMLElement.cpp	3 Jul 2007 16:41:00 -0000
@@ -3936,7 +3936,7 @@
   }

   if (document-&gt;HasFlag(NODE_IS_EDITABLE)) {
-    return this == document-&gt;GetRootContent();
+    return this == (const nsIContent*)document-&gt;GetRootContent();
   }

   if (!HasFlag(NODE_IS_EDITABLE)) {
</pre>
<ul>
  <li>VC6 gets confused by scoped references to sibling inner classes. However they were unnecessary and have since been removed:</li>
</ul>
<pre class="eval">Index: nsCycleCollector.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/base/nsCycleCollector.cpp,v
retrieving revision 1.34
diff -u -r1.34 nsCycleCollector.cpp
--- nsCycleCollector.cpp	25 Apr 2007 21:12:11 -0000	1.34
+++ nsCycleCollector.cpp	26 Apr 2007 22:09:05 -0000
@@ -392,7 +392,7 @@
         {
         }

-        EdgePool::Iterator Mark() { return EdgePool::Iterator(mCurrent); }
+        Iterator Mark() { return Iterator(mCurrent); }

         void Add(PtrInfo* aEdge) {
             if (mCurrent == mBlockEnd) {
@@ -412,7 +412,7 @@
     private:
         // mBlockEnd points to space for null sentinel
         PtrInfoOrBlock *mCurrent, *mBlockEnd;
-        EdgePool::Block **mNextBlockPtr;
+        Block **mNextBlockPtr;
     };

 };
</pre>
<ul>
  <li>VC6 only allows a simple type name in a virtual method override. Furthermore it confuses inner classes that have the same simple name. This means that it can't inherit type names. This required changes to nsCycleCollectionParticipant.h which has been moved from xpcom/base to xpcom/glue, and one of the changes to nsHTMLSelectElement has been moved from the .cpp to the .h file. Another patch that required this has (temporarily?) been backed out:</li>
</ul>
<pre class="eval">Index: nsCycleCollectionParticipant.h
===================================================================
RCS file: /cvsroot/mozilla/xpcom/base/nsCycleCollectionParticipant.h,v
retrieving revision 1.18
diff -u -r1.18 nsCycleCollectionParticipant.h
--- nsCycleCollectionParticipant.h	11 Jul 2007 08:46:49 -0000	1.18
+++ nsCycleCollectionParticipant.h	12 Jul 2007 11:20:24 -0000
@@ -137,11 +137,11 @@
 // Helpers for implementing a QI to nsXPCOMCycleCollectionParticipant
 ///////////////////////////////////////////////////////////////////////////////

-#define NS_CYCLE_COLLECTION_INNERCLASS                                         \
-        cycleCollection
+#define NS_CYCLE_COLLECTION_INNERCLASS(_class)                                 \
+        cycleCollection_ ## _class

 #define NS_CYCLE_COLLECTION_CLASSNAME(_class)                                  \
-        _class::NS_CYCLE_COLLECTION_INNERCLASS
+        _class::NS_CYCLE_COLLECTION_INNERCLASS(_class)

 #define NS_CYCLE_COLLECTION_NAME(_class)                                       \
         _class##_cycleCollectorGlobal
@@ -197,7 +197,7 @@
     NS_ASSERTION(CheckForRightISupports(s),                                    \
                  "not the nsISupports pointer we expect");                     \
     _class *tmp = static_cast&lt;_class*&gt;(Downcast(s));                           \
-    NS_CYCLE_COLLECTION_CLASSNAME(_base_class)::Unlink(s);
+    NS_CYCLE_COLLECTION_INNERCLASS(_base_class)::Unlink(s);

 #define NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(_class)                   \
   NS_IMETHODIMP                                                                \
@@ -269,7 +269,7 @@
     NS_ASSERTION(CheckForRightISupports(s),                                    \
                  "not the nsISupports pointer we expect");                     \
     _class *tmp = static_cast&lt;_class*&gt;(Downcast(s));                           \
-    NS_CYCLE_COLLECTION_CLASSNAME(_base_class)::Traverse(s, cb);
+    NS_CYCLE_COLLECTION_INNERCLASS(_base_class)::Traverse(s, cb);

 #define NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(_class)                 \
   NS_IMETHODIMP                                                                \
@@ -323,7 +323,7 @@
 ///////////////////////////////////////////////////////////////////////////////

 #define NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(_class, _base)                \
-class NS_CYCLE_COLLECTION_INNERCLASS                                           \
+class NS_CYCLE_COLLECTION_INNERCLASS(_class)                                   \
  : public nsXPCOMCycleCollectionParticipant                                    \
 {                                                                              \
 public:                                                                        \
@@ -342,14 +342,17 @@
   {                                                                            \
     return NS_ISUPPORTS_CAST(_base*, p);                                       \
   }                                                                            \
-};
+};                                                                             \
+friend class NS_CYCLE_COLLECTION_INNERCLASS(_class);

 #define NS_DECL_CYCLE_COLLECTION_CLASS(_class)                                 \
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(_class, _class)

 #define NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(_class, _base_class)          \
-class NS_CYCLE_COLLECTION_INNERCLASS                                           \
- : public NS_CYCLE_COLLECTION_CLASSNAME(_base_class)                           \
+typedef class NS_CYCLE_COLLECTION_CLASSNAME(_base_class)                       \
+              NS_CYCLE_COLLECTION_INNERCLASS(_base_class);                     \
+class NS_CYCLE_COLLECTION_INNERCLASS(_class)                                   \
+ : public NS_CYCLE_COLLECTION_INNERCLASS(_base_class)                          \
 {                                                                              \
 public:                                                                        \
   NS_IMETHOD Unlink(void *p);                                                  \
@@ -360,12 +363,15 @@
     return static_cast&lt;_class*&gt;(static_cast&lt;_base_class*&gt;(                     \
       NS_CYCLE_COLLECTION_CLASSNAME(_base_class)::Downcast(s)));               \
   }                                                                            \
-};
+};                                                                             \
+friend class NS_CYCLE_COLLECTION_INNERCLASS(_class);

 #define NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(_class,             \
                                                            _base_class)        \
-class NS_CYCLE_COLLECTION_INNERCLASS                                           \
- : public NS_CYCLE_COLLECTION_CLASSNAME(_base_class)                           \
+typedef class NS_CYCLE_COLLECTION_CLASSNAME(_base_class)                       \
+              NS_CYCLE_COLLECTION_INNERCLASS(_base_class);                     \
+class NS_CYCLE_COLLECTION_INNERCLASS(_class)                                   \
+ : public NS_CYCLE_COLLECTION_INNERCLASS(_base_class)                          \
 {                                                                              \
 public:                                                                        \
   NS_IMETHOD Traverse(void *p,                                                 \
@@ -375,7 +381,8 @@
     return static_cast&lt;_class*&gt;(static_cast&lt;_base_class*&gt;(                     \
       NS_CYCLE_COLLECTION_CLASSNAME(_base_class)::Downcast(s)));               \
   }                                                                            \
-};
+};                                                                             \
+friend class NS_CYCLE_COLLECTION_INNERCLASS(_class);

 /**
  * This implements a stub UnmarkPurple function for classes that want to be
@@ -399,7 +406,7 @@
         _class::NS_CYCLE_COLLECTION_NATIVE_INNERNAME

 #define NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(_class)                          \
-  class NS_CYCLE_COLLECTION_INNERCLASS                                         \
+  class NS_CYCLE_COLLECTION_INNERCLASS(_class)                                 \
    : public nsCycleCollectionParticipant                                       \
   {                                                                            \
   public:                                                                      \
@@ -409,7 +416,8 @@
     NS_IMETHOD Traverse(void *n,                                               \
                       nsCycleCollectionTraversalCallback &amp;cb);                 \
   };                                                                           \
-  static NS_CYCLE_COLLECTION_INNERCLASS                                        \
+  friend class NS_CYCLE_COLLECTION_INNERCLASS(_class);                         \
+  static NS_CYCLE_COLLECTION_INNERCLASS(_class)                                \
       NS_CYCLE_COLLECTION_NATIVE_INNERNAME;

 #define NS_IMPL_CYCLE_COLLECTION_NATIVE_CLASS(_class)                          \
</pre>
<pre class="eval">Index: nsHTMLSelectElement.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/html/content/src/nsHTMLSelectElement.cpp,v
retrieving revision 1&amp;3
diff -u -r1&amp;3 nsHTMLSelectElement.cpp
--- nsHTMLSelectElement.cpp	8 Mar 2007 11:17:12 -0000	1&amp;3
+++ nsHTMLSelectElement.cpp	11 Mar 2007 16:57:41 -0000
@@ -294,7 +294,7 @@
   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;

   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsHTMLSelectElement,
-                                                     nsGenericHTMLFormElement)
+                                                     nsGenericElement)

 protected:
   // Helper Methods
</pre>
<pre class="eval">Index: nsXTFElementWrapper.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/xtf/src/nsXTFElementWrapper.cpp,v
retrieving revision 1.46
diff -u -r1.46 nsXTFElementWrapper.cpp
--- nsXTFElementWrapper.cpp	18 Jun 2007 22:27:28 -0000	1.46
+++ nsXTFElementWrapper.cpp	19 Jun 2007 09:17:00 -0000
@@ -109,7 +109,7 @@

 NS_IMPL_CYCLE_COLLECTION_CLASS(nsXTFElementWrapper)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXTFElementWrapper,
-                                                  nsXTFElementWrapperBase)
+                                                  nsGenericElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXTFElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAttributeHandler)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
Index: nsXTFElementWrapper.h
===================================================================
RCS file: /cvsroot/mozilla/content/xtf/src/nsXTFElementWrapper.h,v
retrieving revision 1.32
diff -u -r1.32 nsXTFElementWrapper.h
--- nsXTFElementWrapper.h	18 Jun 2007 22:27:28 -0000	1.32
+++ nsXTFElementWrapper.h	19 Jun 2007 09:17:01 -0000
@@ -66,7 +66,7 @@
   // nsISupports interface
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsXTFElementWrapper,
-                                                     nsXTFElementWrapperBase)
+                                                     nsGenericElement)

   // nsIXTFElementWrapper
   NS_DECL_NSIXTFELEMENTWRAPPER
</pre>
<ul>
  <li>VC6 won't allow access to a protected or private member of the base type of an nsRefPtr. The context of this patch has since changed:</li>
</ul>
<pre class="eval">Index: nsViewManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/view/src/nsViewManager.cpp,v
retrieving revision 3.458
diff -u -r3.458 nsViewManager.cpp
--- nsViewManager.cpp	22 Aug 2007 02:57:08 -0000	3.458
+++ nsViewManager.cpp	23 Aug 2007 09:23:49 -0000
@@ -1029,7 +1029,7 @@
             if (widget)
                 widget-&gt;GetWindowTranslucency(translucentWindow);

-            if (rootVM-&gt;mScrollCnt == 0 &amp;&amp; !translucentWindow) {
+            if (rootVM.get()-&gt;mScrollCnt == 0 &amp;&amp; !translucentWindow) {
               nsIViewObserver* observer = GetViewObserver();
               if (observer) {
                 // Do an update view batch.  Make sure not to do it DEFERRED,
</pre>
<ul>
  <li>VC6 thinks that typename *varname( is the beginning of a function pointer declaration, rather than a C++ style constructor. This required changes to nsExternalHelperAppService.cpp that have since been removed:</li>
</ul>
<pre class="eval">Index: nsExternalHelperAppService.cpp
===================================================================
RCS file: /cvsroot/mozilla/uriloader/exthandler/nsExternalHelperAppService.cpp,v
retrieving revision 1.314
diff -u -r1.314 nsExternalHelperAppService.cpp
--- nsExternalHelperAppService.cpp	5 Jul 2007 19:31:46 -0000	1.314
+++ nsExternalHelperAppService.cpp	6 Jul 2007 22:25:31 -0000
@@ -860,7 +860,7 @@
       nsCOMPtr&lt;nsIFile&gt; application;
       GetFileTokenForPath(stringValue, getter_AddRefs(application));
       if (application) {
-        nsLocalHandlerApp *handlerApp(new nsLocalHandlerApp(appName, application));
+        nsLocalHandlerApp *handlerApp = new nsLocalHandlerApp(appName, application);
         if (!handlerApp) {
           return NS_ERROR_OUT_OF_MEMORY;
         }
@@ -873,8 +873,8 @@
       FillLiteralValueFromTarget(externalAppNodeResource, kNC_UriTemplate,
                                  &amp;stringValue);
       if (stringValue &amp;&amp; stringValue[0]) {
-        nsWebHandlerApp *handlerApp(new nsWebHandlerApp(appName,
-          NS_ConvertUTF16toUTF8(stringValue)));
+        nsWebHandlerApp *handlerApp = new nsWebHandlerApp(appName,
+          NS_ConvertUTF16toUTF8(stringValue));

         if (!handlerApp) {
             return NS_ERROR_OUT_OF_MEMORY;
@@ -2603,8 +2603,8 @@

   mReceivedDispositionInfo = PR_TRUE;
   if (mMimeInfo &amp;&amp; aApplication) {
-    nsLocalHandlerApp *handlerApp(new nsLocalHandlerApp(EmptyString(),
-                                                        aApplication));
+    nsLocalHandlerApp *handlerApp = new nsLocalHandlerApp(EmptyString(),
+                                                          aApplication);
     mMimeInfo-&gt;SetPreferredApplicationHandler(handlerApp);
   }
</pre>
<ul>
  <li>VC6 can't resolve a global template reference from within the definition of the template. However nsTObserverArray has now been rewritten so it requires a completely new set of fixes:</li>
</ul>
<pre class="eval">Index: nsTObserverArray.h
===================================================================
RCS file: /cvsroot/mozilla/xpcom/glue/nsTObserverArray.h,v
retrieving revision 1.4
diff -u -r1.4 nsTObserverArray.h
--- nsTObserverArray.h	14 Dec 2007 01:41:49 -0000	1.4
+++ nsTObserverArray.h	15 Dec 2007 21:06:21 -0000
@@ -241,8 +241,6 @@
     // observers added to the array after the iterator was created.
     class EndLimitedIterator : private ForwardIterator {
       public:
-        typedef typename nsTObserverArray&lt;T&gt;::ForwardIterator base_type;
-
         EndLimitedIterator(const nsTObserverArray&lt;T&gt;&amp; aArray)
           : ForwardIterator(aArray),
             mEnd(aArray, aArray.Count()) {
@@ -256,7 +254,7 @@
          */
         T* GetNext() {
           return (*this &lt; mEnd) ?
-                 static_cast&lt;T*&gt;(FastElementAt(base_type::mPosition++)) :
+                 static_cast&lt;T*&gt;(FastElementAt(this-&gt;mPosition++)) :
                  nsnull;
         }

</pre>
<ul>
  <li>VC6 can't specialise a template with a constant. Removal of the specialisation used to require the changing of an assumption, but the code has since been fixed to allocate reasonably in more cases, which includes this edge case:</li>
</ul>
<pre class="eval">Index: nsTArray.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/glue/nsTArray.cpp,v
retrieving revision 1.13
diff -u -r1.13 nsTArray.cpp
--- nsTArray.cpp	20 Dec 2007 09:33:03 -0000	1.13
+++ nsTArray.cpp	21 Dec 2007 14:04:41 -0000
@@ -67,7 +67,7 @@
     return PR_FALSE;
   }

-  if (mHdr == &amp;sEmptyHdr) {
+  if (!mHdr-&gt;mCapacity) {
     // NS_Alloc new data
     Header *header = static_cast&lt;Header*&gt;
                                 (NS_Alloc(sizeof(Header) + capacity * elemSize));
@@ -82,7 +82,6 @@
   }

   // Use doubling algorithm when forced to increase available capacity.
-  NS_ASSERTION(mHdr-&gt;mCapacity &gt; 0, "should not have buffer of zero size");
   size_type temp = mHdr-&gt;mCapacity;
   while (temp &lt; capacity)
     temp &lt;&lt;= 1;
</pre>
