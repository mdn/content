---
title: Sorting algorithms comparison
slug: Tools/Performance/Examples/Sorting_algorithms_comparison
---
<div>{{ToolsSidebar}}</div><p>This article describes a simple example program that we use in two of the Performance guides: the guide to the <a href="/en-US/docs/Tools/Performance/Call_Tree">Call Tree</a> and the guide to the <a href="/en-US/docs/Tools/Performance/Flame_Chart">Flame Chart</a>.</p>

<p>This program compares the performance of three different sorting algorithms:</p>

<ul>
 <li>bubble sort</li>
 <li>selection sort</li>
 <li>quicksort</li>
</ul>

<p>It consists of the following functions:</p>

<table class="standard-table">
 <tbody>
  <tr>
   <td><strong><code>sortAll()</code></strong></td>
   <td>Top-level function. Iteratively (200 iterations) generates a randomized array and calls <code>sort()</code>.</td>
  </tr>
  <tr>
   <td><strong><code>sort()</code></strong></td>
   <td>Calls each of <code>bubbleSort()</code>, <code>selectionSort()</code>, <code>quickSort()</code> in turn and logs the result.</td>
  </tr>
  <tr>
   <td><strong><code>bubbleSort()</code></strong></td>
   <td>Implements a bubble sort, returning the sorted array.</td>
  </tr>
  <tr>
   <td><strong><code>selectionSort()</code></strong></td>
   <td>Implements a selection sort, returning the sorted array.</td>
  </tr>
  <tr>
   <td><strong><code>quickSort()</code></strong></td>
   <td>Implements quicksort, returning the sorted array.</td>
  </tr>
  <tr>
   <td><code><strong>swap()</strong></code></td>
   <td>Helper function for <code>bubbleSort()</code> and <code>selectionSort()</code>.</td>
  </tr>
  <tr>
   <td><code><strong>partition()</strong></code></td>
   <td>Helper function for <code>quickSort()</code>.</td>
  </tr>
 </tbody>
</table>

<p>Its call graph looks like this:</p>

<pre>sortAll()                     // (generate random array, then call sort) x 200

    -&gt; sort()                 // sort with each algorithm, log the result

        -&gt; bubbleSort()

            -&gt; swap()

        -&gt; selectionSort()

            -&gt; swap()

        -&gt; quickSort()

            -&gt; partition()</pre>

<p>The implementations of the sorting algorithms in the program are taken from <a href="https://github.com/nzakas/computer-science-in-javascript/">https://github.com/nzakas/computer-science-in-javascript/</a> and are used under the MIT license.</p>

<p>You can try out the example program <a href="https://mdn.github.io/performance-scenarios/js-call-tree-1/index.html">here</a> and clone the code <a href="https://github.com/mdn/performance-scenarios">here</a> (be sure to check out the gh-pages branch). You can also <a href="https://github.com/mdn/performance-scenarios/tree/gh-pages/js-call-tree-1/profile">download the specific profile we discuss</a> - just import it to the Performance tool if you want to follow along. Of course, you can generate your own profile, too, but the numbers will be a little different.</p>
