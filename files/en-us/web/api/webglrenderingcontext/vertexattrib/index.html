---
title: 'WebGLRenderingContext.vertexAttrib[1234]f[v]()'
slug: Web/API/WebGLRenderingContext/vertexAttrib
tags:
- API
- Method
- Reference
- WebGL
- WebGLRenderingContext
browser-compat: api.WebGLRenderingContext.vertexAttrib1f
---
<div>{{APIRef("WebGL")}}</div>

<p>The <strong><code>WebGLRenderingContext.vertexAttrib[1234]f[v]()</code></strong>
  methods of the <a href="/en-US/docs/Web/API/WebGL_API">WebGL API</a> specify constant
  values for generic vertex attributes.</p>

<h2 id="Syntax">Syntax</h2>

<pre class="brush: js">void <var>gl</var>.vertexAttrib1f(<var>index</var>, <var>v0</var>);
void <var>gl</var>.vertexAttrib2f(<var>index</var>, <var>v0</var>, <var>v1</var>);
void <var>gl</var>.vertexAttrib3f(<var>index</var>, <var>v0</var>, <var>v1</var>, <var>v2</var>);
void <var>gl</var>.vertexAttrib4f(<var>index</var>, <var>v0</var>, <var>v1</var>, <var>v2</var>, <var>v3</var>);

void <var>gl</var>.vertexAttrib1fv(<var>index</var>, <var>value</var>);
void <var>gl</var>.vertexAttrib2fv(<var>index</var>, <var>value</var>);
void <var>gl</var>.vertexAttrib3fv(<var>index</var>, <var>value</var>);
void <var>gl</var>.vertexAttrib4fv(<var>index</var>, <var>value</var>);
</pre>

<h3 id="Parameters">Parameters</h3>

<dl>
  <dt><code>index</code></dt>
  <dd>A {{domxref("GLuint")}} specifying the position of the vertex attribute to be
    modified.</dd>
  <dt><code>v0, v1, v2, v3</code></dt>
  <dd>A floating point {{jsxref("Number")}} for the vertex attribute value.</dd>
  <dt><code>value</code></dt>
  <dd>
    <p>A {{jsxref("Float32Array")}} for floating point vector vertex attribute values.</p>
  </dd>
</dl>

<h3 id="Return_value">Return value</h3>

<p>None.</p>

<h2 id="Description">Description</h2>

<p>While vertex attributes are usually used to specify values which are different for each
  vertex (using {{domxref("WebGLRenderingContext.vertexAttribPointer()",
  "vertexAttribPointer")}}), it can be useful to specify a constant value. For example, if
  you have a shader which has a <code>color</code> vertex attribute, but you want to draw
  everything in a single color, you can use <code>vertexAttrib</code> to achieve that
  without creating a buffer filled with only one value or having to create a separate
  shader which uses a uniform for the color.</p>

<p>This value will be used if a bound array buffer has not been enabled with
  {{domxref("WebGLRenderingContext.enableVertexAttribArray()",
  "enableVertexAttribArray")}}.</p>

<p>Attributes may be matrices, in which case columns of the matrix must be loaded into
  successive vertex attribute slots.</p>

<p>The values set with {{domxref("WebGLRenderingContext.vertexAttribPointer()",
  "vertexAttribPointer")}} are context-global, i.e. they aren't part of the shader state
  (like generix vertex attribute indexes to shader variable bindings) and aren't part of
  the vertex array object state (like enabled vertex attribute arrays). The only way to
  change the values is by calling this function again.</p>

<h2 id="Examples">Examples</h2>

<pre class="brush: js">const a_foobar = gl.getAttribLocation(shaderProgram, 'foobar');
//either set each component individually:
gl.vertexAttrib3f(a_foobar, 10.0, 5.0, 2.0);
//or provide a Float32Array:
const floatArray = new Float32Array([10.0, 5.0, 2.0]);
gl.vertexAttrib3fv(a_foobar, floatArray);</pre>


<pre class="brush: js">// we want to load the following 3x3 matrix into attribute named "matrix3x3"
// 0 1 2
// 3 4 5
// 6 7 8
const matrix3x3Location = gl.getAttribLocation(shaderProgram, 'matrix3x3');
gl.vertexAttrib3f(matrix3x3Location,     0, 3, 6);
gl.vertexAttrib3f(matrix3x3Location + 1, 1, 4, 7);
gl.vertexAttrib3f(matrix3x3Location + 2, 2, 5, 8);
</pre>

<h2 id="Specifications">Specifications</h2>

{{Specifications}}

<h2 id="Browser_compatibility">Browser compatibility</h2>

<p>{{Compat}}</p>

<h2 id="See_also">See also</h2>

<ul>
  <li>{{domxref("WebGLRenderingContext.getVertexAttrib()")}}</li>
</ul>
