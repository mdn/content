---
title: URLPattern
slug: Web/API/URLPattern
tags:
- API
- Interface
- Reference
- URLPattern
- URLPattern API
- Web
- Polyfill
- Experimental
browser-compat: api.URLPattern
---
<p>{{APIRef("URLPattern API")}}</p>

<p>
  The <strong><code>URLPattern</code></strong> interface matches URLs or parts
  of URLs against a pattern. The pattern can contain capturing groups that
  extract parts of the matched URL.
</p>

<p>
  The pattern syntax is based on the syntax from the <a href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a> library.
  Patterns can contain:
  <ul>
    <li>Literal strings which will be matched exactly.</li>
    <li>Wildcards (<code>/posts/*</code>) that can be used to match any character.</li>
    <li>Named groups (<code>/books/:id</code>) which can be used to extract a part of the matched URL.</li>
    <li>Non-capturing groups (<code>/books{/old}?</code>) which can be used to make parts of a pattern optional or be matched multiple times.</li>
    <li>{{jsxref("RegExp")}} groups (<code>/books/(^\d)</code>) to do arbitrarially complex regex matches.</li>
  </ul>
  Further details about the syntax can be found in the
  <a href="#pattern_syntax">pattern syntax</a> section below.
</p>

<p>{{AvailableInWorkers}}</p>

<h2 id="Constructor">Constructor</h2>

<dl>
  <dt>{{domxref("URLPattern.URLPattern", "URLPattern()")}}</dt>
  <dd>
    Returns a new <code>URLPattern</code> object based on the given pattern
    and base URL.
  </dd>
</dl>

<h2 id="Properties">Properties</h2>

<dl>
  <dt>{{domxref("URLPattern.hash", "hash")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the <em>hash</em>
    part of a URL.
  </dd>
  <dt>{{domxref("URLPattern.hostname", "hostname")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the
    <em>hostname</em> part of a URL.
  </dd>
  <dt>{{domxref("URLPattern.password", "password")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the
    <em>password</em> part of a URL.
  </dd>
  <dt>{{domxref("URLPattern.pathname", "pathname")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the
    <em>pathname</em> part of a URL.
  </dd>
  <dt>{{domxref("URLPattern.port", "port")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the <em>port</em>
    part of a URL.
  </dd>
  <dt>{{domxref("URLPattern.protocol", "protocol")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the
    <em>protocol</em> part of a URL.
  </dd>
  <dt>{{domxref("URLPattern.search", "search")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the <em>search</em>
    part of a URL.
  </dd>
  <dt>{{domxref("URLPattern.username","username")}}</dt>
  <dd>
    A {{domxref("USVString")}} containing a pattern to match the
    <em>username</em> part of a URL.
  </dd>
</dl>

<h2 id="Methods">Methods</h2>

<dl>
  <dt>{{domxref("URLPattern.exec", "exec()")}}</dt>
  <dd>
    Returns an object with the matched parts of the URL or <code>null</code> if
    the URL does not match.
  </dd>
  <dt>{{domxref("URLPattern.test", "test()")}}</dt>
  <dd>
    Returns <code>true</code> if the URL matches the given pattern,
    <code>false</code> otherwise.
  </dd>
</dl>

<h2 id="Usage_notes">Usage notes</h2>

<p>
  The <code>URLPattern</code> constructor has two forms. The constructor either
  takes a pattern object, or a pattern string and optional baseURL.
</p>

<pre class="brush: js">
new URLPattern(<var>obj</var>);
new URLPattern(<var>pattern</var>[, <var>baseURL</var>]);
</pre>

<p>
  The first type of constructor (see above) takes an object that describes the
  URLs that should be matched by specifying patterns for each individual URL
  part. Its members can be any of <code>protocol</code>, <code>username</code>,
  <code>password</code>, <code>hostname</code>, <code>port</code>,
  <code>pathname</code>, <code>search</code>, <code>hash</code>, or
  <code>baseURL</code>. If the baseURL property is provided it will be parsed as
  a URL and used to populate any other properties that are missing. If the
  baseURL property is missing, then any other missing properties default to the
  pattern <code>*</code> wildcard, accepting any input.
</p>
  
<p>
  The second type of constructor (see above) takes a URL string that contains
  patterns embedded in it. The URL string may be relative if a base URL is provided as
  the second argument. Note, it may be necessary to escape some characters in
  the URL string where its ambiguous whether the character is separating
  different URL components or if it's instead part of a pattern. For example,
  you must write <code>about\\:blank</code> to indicate that the <code>:</code>
  is the protocol suffix and not the start of a <code>:blank</code> named group
  pattern.
</p>

<h2 id="Pattern_syntax">Pattern syntax</h2>

<p>
  The syntax for patterns is based on the
  <a href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a>
  JavaScript library. This syntax is similar to the one used in
  <a href="https://rubyonrails.org">Ruby on Rails</a>, or JavaScript frameworks
  like <a href="https://expressjs.com/">Express</a>
  or <a href="https://next.js">Next.js</a>.
</p>

<p>
  Each pattern can contain a combination of fixed text, and groups. The fixed
  text is a sequence of characters that is matched exactly. Groups match an
  arbitrary string based on some matching rules. Each URL part has its own
  default rules that are explained below, but they can be overwritten.
</p>

<pre class="brush: js">
// A pattern matching some fixed text
const pattern = new URLPattern({ pathname: '/books' });
console.log(pattern.test('https://example.com/books')); // true
console.log(pattern.exec('https://example.com/books').pathname.groups); // {}

// A pattern matching with a named group
const pattern = new URLPattern({ pathname: '/books/:id' });
console.log(pattern.test('https://example.com/books/123')); // true
console.log(pattern.exec('https://example.com/books/123').pathname.groups); // { id: '123' }
</pre>

<p>
  By default, a group matching inside the <code>pathname</code> part of the URL
  will match all characters but the forward slash (<code>/</code>). In the
  <code>hostname</code> part, the group will match all characters except the dot
  (<code>.</code>). In all other parts, the group will match all characters.
  The segment wildcard is non-greedy, meaning that it will match the shortest
  possible string.
</p>

<p>
  Instead of using the default match rules for a group, a regex can be specified
  per group. This regex defines the matching rules for the group. Below is an
  example of a regex matcher on a named group that constrains the group to only
  match if it contains one or more digits:
</p>

<pre class="brush: js">
const pattern = new URLPattern('/books/:id(\\d+)', 'https://example.com');
console.log(pattern.test('https://example.com/books/123')); // true
console.log(pattern.test('https://example.com/books/abc')); // false
console.log(pattern.test('https://example.com/books/')); // false
</pre>
  
  
<p>
  Groups can either be named or unnamed. Named groups are specified by prefixing
  the group name with a colon (<code>:</code>). Regexp groups that are not
  prefixed by a colon and a name are unnamed. Unamed groups are numerically
  indexed in the match result based on their order in the pattern.
</p>

<pre class="brush: js">
// A named group
const pattern = new URLPattern('/books/:id(\\d+)', 'https://example.com');
console.log(pattern.exec('https://example.com/books/123').pathname.groups); // { id: '123' }

// An unnamed group
const pattern = new URLPattern('/books/(\\d+)', 'https://example.com');
console.log(pattern.exec('https://example.com/books/123').pathname.groups); // { '0': '123' }
</pre>

<p>
  Groups can also have modifiers. These are specified after the group name (or
  after the regexp if there is one). There are three modifiers: <code>?</code>
  to make the group optional, <code>+</code> to make the group repeat one or
  more times, and <code>*</code> to make the group repeat zero or more times.
</p>

<pre class="brush: js">
// An optional group
const pattern = new URLPattern('/books/:id?', 'https://example.com');
console.log(pattern.test('https://example.com/books/123')); // true
console.log(pattern.test('https://example.com/books')); // true
console.log(pattern.test('https://example.com/books/')); // false
console.log(pattern.test('https://example.com/books/123/456')); // false
console.log(pattern.test('https://example.com/books/123/456/789')); // false

// A repeating group with a minimum of one
const pattern = new URLPattern('/books/:id+', 'https://example.com');
console.log(pattern.test('https://example.com/books/123')); // true
console.log(pattern.test('https://example.com/books')); // false
console.log(pattern.test('https://example.com/books/')); // false
console.log(pattern.test('https://example.com/books/123/456')); // true
console.log(pattern.test('https://example.com/books/123/456/789')); // true

// A repeating group with a minimum of zero
const pattern = new URLPattern('/books/:id*', 'https://example.com');
console.log(pattern.test('https://example.com/books/123')); // true
console.log(pattern.test('https://example.com/books')); // true
console.log(pattern.test('https://example.com/books/')); // false
console.log(pattern.test('https://example.com/books/123/456')); // true
console.log(pattern.test('https://example.com/books/123/456/789')); // true
</pre>

<p>
  Next to capturing groups, there are also non-capturing groups. These are
  pieces of a pattern that are surrounded by curly braces (<code>{}</code>).
  These groups are not captured in the match result, but can still have modifiers
  applied to them. If a non-capturing group does not have a modifier, it is
  treated as if the items in the group were not surrounded by curly braces.
</p>

<pre class="brush: js">
// A non-capturing group with a ? (optional) modifier
const pattern = new URLPattern('/book{s}?', 'https://example.com');
console.log(pattern.test('https://example.com/books')); // true
console.log(pattern.test('https://example.com/book')); // true
console.log(pattern.exec('https://example.com/books').pathname.groups); // {}

// A non-capturing group without a modifier
const pattern = new URLPattern('/book{s}', 'https://example.com');
console.log(pattern.pathname); // /books
console.log(pattern.test('https://example.com/books')); // true
console.log(pattern.test('https://example.com/book')); // false
</pre>

<p>
  A shorthand for an unamed capturing group that matches all characters zero or
  more times is provided by the wildcard token (<code>*</code>). This can be
  can be placed anywhere in the pattern. The wilcard is greedy, meaning that it
  will match the longest possible string.
</p>

<pre class="brush: js">
// A wildcard at the end of a pattern
const pattern = new URLPattern('/books/', 'https://example.com');
console.log(pattern.test('https://example.com/books/123')); // true
console.log(pattern.test('https://example.com/books')); // false
console.log(pattern.test('https://example.com/books/')); // true
console.log(pattern.test('https://example.com/books/123/456')); // true

// A wildcard in the middle of a pattern
const pattern = new URLPattern('/*.png', 'https://example.com');
console.log(pattern.test('https://example.com/image.png')); // true
console.log(pattern.test('https://example.com/image.png/123')); // false
console.log(pattern.test('https://example.com/folder/image.png')); // true
console.log(pattern.test('https://example.com/.png')); // true
</pre>

<p>
  When a pattern is parsed it is automatically normalized to a canonical form.
  For example, unicode characters are percent encoded in the pathname property,
  punycode encoding is used in the hostname, default port numbers are elided,
  paths like <code>/foo/./bar/</code> are collapsed to just
  <code>/foo/bar</code>, etc. In addition, there are some pattern
  representations that parse to the same underlying meaning, like
  <code>foo</code> and <code>{foo}</code>. Such cases are normalized to the
  simplest form. In this case <code>{foo}</code> gets changed to
  <code>foo</code>.
</p>

<h2 id="Examples">Examples</h2>

<h3>Filter on a specific URL component</h3>

<p>
  The following example shows how a <code>URLPattern</code> filters a
  specific URL component. When the <code>URLPattern()</code> constructor is
  called with a structured object of component patterns any missing components
  default to the <code>*</code> wildcard value.
</p>

<pre class="brush: js">
// Construct a URLPattern that matches a specific domain and its subdomains.
// All other URL components default to the wildcard `*` pattern.
const pattern = new URLPattern({
  hostname: "{*.}?example.com"
});

console.log(pattern.hostname); // "{*.}?example.com"

console.log(pattern.protocol); // "*"
console.log(pattern.username); // "*"
console.log(pattern.password); // "*"
console.log(pattern.pathname); // "*"
console.log(pattern.search); // "*"
console.log(pattern.hash); // "*"

console.log(pattern.test("https://example.com/foo/bar")); // true

console.log(pattern.test({ hostname: "cdn.example.com" })); // true

console.log(pattern.test("custom-protocol://example.com/other/path?q=1")); // true

// Prints `false` because the hostname component does not match
console.log(pattern.test("https://cdn-example.com/foo/bar"));
</pre>

<h3>Construct a URLPattern from a full URL string</h3>

<p>
  The following example shows how a <code>URLPattern</code> can be constructed
  from a full URL string with patterns embedded. For example, a <code>:</code>
  can be both the URL protocol suffix, like <code>https:</code>, and the
  beginning of a named pattern group, like <code>:foo</code>. If there is no
  ambiguity between whether a character is a part of the URL syntax or part of
  the pattern syntax then it just works.
</p>

<pre class="brush: js">
// Construct a URLPattern that matches URLs to CDN servers loading jpg images.
// URL components not explicitly specified, like search and hash here, result
// in the empty string similar to the URL() constructor.
const pattern = new URLPattern("https://cdn-*.example.com/*.jpg");

console.log(pattern.protocol); // "https"

console.log(pattern.hostname); // "cdn-*.example.com"

console.log(pattern.pathname); // "/*.jpg"

console.log(pattern.username); // ""
console.log(pattern.password); // ""
console.log(pattern.search); // ""
console.log(pattern.hash); // ""

// Prints `true`
console.log(
    pattern.test("https://cdn-1234.example.com/product/assets/hero.jpg");

// Prints `false` because the search component does not match
console.log(
    pattern.test("https://cdn-1234.example.com/product/assets/hero.jpg?q=1");
</pre>

<h3>Constructing a URLPattern with an ambiguous URL string</h3>

<p>
  The following example shows how a URLPattern constructed from an ambiguous
  string will favor treating characters as part of the pattern syntax. In
  this case the <code>:</code> character could be the protocol component suffix
  or it could be the prefix for a named group in the pattern. The constructor
  chooses to treat this as part of the pattern and therefore determines this is
  a relative pathname pattern. Since there is no base URL the relative pathname
  cannot be resolved and it throws an error.
</p>

<pre class="brush: js">
// Throws because this is interpreted as a single relative pathname pattern
// with a ":foo" named group and there is no base URL.
const pattern = new URLPattern("data:foo*");
</pre>

<h3>Escaping characters to disambiguate URLPattern constructor strings</h3>

<p>
  The following example shows how an ambiguous constructor string character
  can be escaped to be treated as a URL separator instead of a pattern
  character. Here <code>:</code> is escaped as <code>\\:</code>.
</p>

<pre class="brush: js">
// Constructs a URLPattern treating the `:` as the protocol suffix.
const pattern = new URLPattern("data\\:foo*");

console.log(pattern.protocol); // "data"

console.log(pattern.pathname); // "foo*"

console.log(pattern.username); // ""
console.log(pattern.password); // ""
console.log(pattern.hostname); // ""
console.log(pattern.port); // ""
console.log(pattern.search); // ""
console.log(pattern.hash); // ""

console.log(pattern.test("data:foobar")); // true
</pre>

<h3>Using base URLs for test() and exec()</h3>

<p>
  The following example shows how input values to <code>test()</code> and
  <code>exec()</code> can use base URLs.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ hostname: "example.com", pathname: "/foo/*" });

// Prints `true` as the hostname based in the dictionary `baseURL` property
// matches.
console.log(
    pattern.test({ pathname: "/foo/bar", baseURL: "https://example.com/baz" }));

// Prints `true` as the hostname in the second argument base URL matches.
console.log(pattern.test("/foo/bar", "https://example.com/baz"));

// Throws because the second argument cannot be passed with a dictionary input.
try {
  pattern.test({ pathname: "/foo/bar" }, "https://example.com/baz");
} catch (e) {}

// The `exec()` method takes the same arguments as `test()`.
const result = pattern.exec("/foo/bar", "https://example.com/baz");

console.log(result.pathname.input); // "/foo/bar"

console.log(result.pathname.groups[0]); // "bar"

console.log(result.hostname.input); // "example.com"
</pre>

<h3>Using base URLs in the URLPattern constructor</h3>

<p>
  The follow example shows how base URLs can also be used to construct the
  <code>URLPattern</code>. It's important to note that the base URL in these
  cases is treated strictly as a URL and cannot contain any pattern syntax
  itself.
</p>

<p>
  Also, since the base URL provides a value for every component the resulting
  <code>URLPattern</code> will also have a value for every component; even if
  it's the empty string. This means you do not get the "default to wildcard"
  behavior.  
</p>

<pre class="brush: js">
const pattern1 = new URLPattern({ pathname: "/foo/*",
                                  baseURL: "https://example.com" });

console.log(pattern1.protocol); // "https"
console.log(pattern1.hostname); // "example.com"
console.log(pattern1.pathname); // "/foo/*"

console.log(pattern1.username); // ""
console.log(pattern1.password); // ""
console.log(pattern1.port); // ""
console.log(pattern1.search); // ""
console.log(pattern1.hash); // ""

// Equivalent to pattern1
const pattern2 = new URLPattern("/foo/*", "https://example.com" });

// Throws because a relative constructor string must have a base URL to resolve
// against.
try {
  const pattern3 = new URLPattern("/foo/*");
} catch (e) {}
</pre>

<h3>Accessing matched group values</h3>

<p>
  The following example shows how input values that match pattern groups can
  later be accessed from the <code>exec()</code> result object. Unnamed groups
  are assigned index numbers sequentially.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ hostname: "*.example.com" });
const result = pattern.exec({ hostname: "cdn.example.com" });

console.log(result.hostname.groups[0]); // "cdn"

console.log(result.hostname.input); // "cdn.example.com"

console.log(result.inputs); // [{ hostname: "cdn.example.com" }]
</pre>

<h3>Accessing matched group values using custom names</h3>

<p>
  The following example shows how groups can be given custom names which can
  be used to accessed the matched value in the result object.  
</p>

<pre class="brush: js">
// Construct a URLPattern using matching groups with custom names.  These
// names can then be later used to access the matched values in the result
// object.
const pattern = new URLPattern({ pathname: "/:product/:user/:action" });
const result = pattern.exec({ pathname: "/store/wanderview/view" });

console.log(result.pathname.groups.product); // "store"
console.log(result.pathname.groups.user); // "wanderview"
console.log(result.pathname.groups.action); // "view"

console.log(result.pathname.input); // "/store/wanderview/view"

console.log(result.inputs); // [{ pathname: "/store/wanderview/view" }]
</pre>

<h3>Custom regular expression groups</h3>

<p>
  The following example shows how a matching group can use a custom regular
  expression.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ pathname: "/(foo|bar)" });

console.log(pattern.test({ pathname: "/foo" })); // true
console.log(pattern.test({ pathname: "/bar" })); // true
console.log(pattern.test({ pathname: "/baz" })); // false

const result = pattern.exec({ pathname: "/foo" });

console.log(result.pathname.groups[0]); // "foo"
</pre>

<h3>Named group with a custom regular expression</h3>

<p>
  The following example shows how a custom regular expression can be used with a
  named group.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ pathname: "/:type(foo|bar)" });
const result = pattern.exec({ pathname: "/foo" });

console.log(result.pathname.groups.type); // "foo"
</pre>

<h3>Making matching groups optional</h3>

<p>
  The following example shows how a matching group can be made optional by
  placing a <code>?</code> modifier after it. For the pathname component this
  also causes any preceding <code>/</code> character to be treated as an
  optional prefix to the group.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ pathname: "/product/(index.html)?" });

console.log(pattern.test({ pathname: "/product/index.html" })); // true
console.log(pattern.test({ pathname: "/product" })); // true

const pattern2 = new URLPattern({ pathname: "/product/:action?" });

console.log(pattern2.test({ pathname: "/product/view" })); // true
console.log(pattern2.test({ pathname: "/product" })); // true

// Wildcards can be made optional as well.  This may not seem to make sense
// since they already match the empty string, but it also makes the prefix
// `/` optional in a pathname pattern.
const pattern3 = new URLPattern({ pathname: "/product/*?" });

console.log(pattern3.test({ pathname: "/product/wanderview/view" })); // true
console.log(pattern3.test({ pathname: "/product" })); // true
console.log(pattern3.test({ pathname: "/product/" })); // true
</pre>

<h3>Making matching groups repeated</h3>

<p>
  The following example shows how a matching group can be made repeated by
  placing a <code>+</code> modifier after it. In the <code>pathname</code>
  component this also treats the <code>/</code> prefix as special. It is
  repeated with the group.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ pathname: "/product/:action+" });
const result = pattern.exec({ pathname: "/product/do/some/thing/cool" });

result.pathname.groups.action; // "do/some/thing/cool"

console.log(pattern.test({ pathname: "/product" })); // false
</pre>

<h3>Making matching groups optional and repeated</h3>

<p>
  The following example shows how a matching group can be made both optional and
  repeated. This is done by placing a <code>*</code> modifier after the group.
  Again, the pathname component treats the <code>/</code> prefix as special. It
  both becomes optional and is also repeated with the group.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ pathname: "/product/:action*" });
const result = pattern.exec({ pathname: "/product/do/some/thing/cool" });

console.log(result.pathname.groups.action); // "do/some/thing/cool"

console.log(pattern.test({ pathname: "/product" })); // true
</pre>

<h3>Using a custom prefix or suffix for an optional or repeated modifier</h3>

<p>
  The following example shows how curly braces can be used to denote a custom
  prefix and/or suffix to be operated on by a subsequent <code>?</code>,
  <code>*</code>, or <code>+</code>
  modifier.
</p>

<pre class="brush: js">
const pattern = new URLPattern({ hostname: "{:subdomain.}*example.com" });

console.log(pattern.test({ hostname: "example.com" })); // true
console.log(pattern.test({ hostname: "foo.bar.example.com" })); // true
console.log(pattern.test({ hostname: ".example.com" })); // false

const result = pattern.exec({ hostname: "foo.bar.example.com" });

console.log(result.hostname.groups.subdomain); // "foo.bar"
</pre>

<h3>Making text optional or repeated without a matching group</h3>

<p>
  The following example shows how curly braces can be used to denote text
  without a matching group can be made optional or repeated without a
  matching group.  
</p>

<pre class="brush: js">
const pattern = new URLPattern({ pathname: "/product{/}?" });

console.log(pattern.test({ pathname: "/product" })); // true
console.log(pattern.test({ pathname: "/product/" })); // true

const result = pattern.exec({ pathname: "/product/" });

console.log(result.pathname.groups); // {}
</pre>

<h3>Using multiple components and features at once</h3>

<p>
  The following example shows how many features can be combined across multiple
  URL components.
</p>

<pre class="brush: js">
const pattern = new URLPattern({
  protocol: "http{s}?",
  username: ":user?",
  password: ":pass?",
  hostname: "{:subdomain.}*example.com",
  pathname: "/product/:action*",
});

const result = pattern.exec("http://foo:bar@sub.example.com/product/view?q=12345");

console.log(result.username.groups.user); // "foo"
console.log(result.password.groups.pass); // "bar"
console.log(result.hostname.groups.subdomain); // "sub"
console.log(result.pathname.groups.action); // "view"
</pre>

<h2 id="Specifications">Specifications</h2>

{{Specifications}}

<h2 id="Browser_compatibility">Browser compatibility</h2>

<p>{{Compat}}</p>

<h2 id="See_also">See also</h2>

<ul>
  <li>
    A polyfill of <code>URLPattern</code> is available
    <a href="https://github.com/kenchris/urlpattern-polyfill">on GitHub</a>
  </li>
  <li>
    The pattern syntax used by URLPattern is similar to the syntax used by
    <a href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a>
</ul>
