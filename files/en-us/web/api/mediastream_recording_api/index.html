---
title: MediaStream Recording API
slug: Web/API/MediaStream_Recording_API
tags:
  - API
  - Audio
  - Media
  - Media Capture and Streams
  - MediaStream Recording
  - MediaStream Recording API
  - Overview
  - Reference
  - Video
---
<div>{{DefaultAPISidebar("MediaStream Recording")}}</div>

<p><span class="seoSummary">The <strong>MediaStream Recording API</strong>, sometimes referred to as the <em>Media Recording API</em> or the <em>MediaRecorder API</em>, is closely affiliated with the <a href="/en-US/docs/Web/API/Media_Streams_API">Media Capture and Streams API</a> and the <a href="/en-US/docs/Web/API/WebRTC_API">WebRTC API</a>. The MediaStream Recording API makes it possible to capture the data generated by a {{domxref("MediaStream")}} or {{domxref("HTMLMediaElement")}} object for analysis, processing, or saving to disk. It's also surprisingly easy to work with.</span></p>

<h2 id="Basic_concepts">Basic concepts</h2>

<p>The MediaStream Recording API is comprised of a single major interface, {{domxref("MediaRecorder")}}, which does all the work of taking the data from a {{domxref("MediaStream")}} and delivering it to you for processing. The data is delivered by a series of {{event("dataavailable")}} events, already in the format you specify when creating the <code>MediaRecorder</code>. You can then process the data further or write it to file as desired.</p>

<h3 id="Overview_of_the_recording_process">Overview of the recording process</h3>

<p>The process of recording a stream is simple:</p>

<ol>
 <li>Set up a {{domxref("MediaStream")}} or {{domxref("HTMLMediaElement")}} (in the form of an {{HTMLElement("audio")}} or {{HTMLElement("video")}} element) to serve as the source of the media data.</li>
 <li>Create a {{domxref("MediaRecorder")}} object, specifying the source stream and any desired options (such as the container's MIME type or the desired bit rates of its tracks).</li>
 <li>Set {{domxref("MediaRecorder.ondataavailable")}} to an event handler for the {{event("dataavailable")}} event; this will be called whenever data is available for you.</li>
 <li>Once the source media is playing and you've reached the point where you're ready to record video, call {{domxref("MediaRecorder.start()")}} to begin recording.</li>
 <li>Your {{event("dataavailable")}} event handler gets called every time there's data ready for you to do with as you will; the event has a <code>data</code> attribute whose value is a {{domxref("Blob")}} that contains the media data. You can force a <code>dataavailable</code> event to occur, thereby delivering the latest sound to you so you can filter it, save it, or whatever.</li>
 <li>Recording stops automatically when the source media stops playing.</li>
 <li>You can stop recording at any time by calling {{domxref("MediaRecorder.stop()")}}.</li>
</ol>

<div class="note">
<p><strong>Note:</strong> Individual {{domxref("Blob")}}s containing slices of the recorded media will not necessarily be individually playable. The media needs to be reassembled before playback.</p>
</div>

<p>If anything goes wrong during recording, an {{event("error")}} event is sent to the <code>MediaRecorder</code>. You can listen for <code>error</code> events by setting up a {{domxref("MediaRecorder.onerror", "onerror")}} event handler.<br>
 <br>
 Example here, we use an HTML Canvas as source of the {{domxref("MediaStream")}}, and stop recording after 9 seconds.</p>

<pre class="brush: js">var canvas = document.querySelector("canvas");

// Optional frames per second argument.
var stream = canvas.captureStream(25);
var recordedChunks = [];

console.log(stream);
var options = { mimeType: "video/webm; codecs=vp9" };
mediaRecorder = new MediaRecorder(stream, options);

mediaRecorder.ondataavailable = handleDataAvailable;
mediaRecorder.start();

function handleDataAvailable(event) {
  console.log("data-available");
  if (event.data.size &gt; 0) {
    recordedChunks.push(event.data);
    console.log(recordedChunks);
    download();
  } else {
    // ...
  }
}
function download() {
  var blob = new Blob(recordedChunks, {
    type: "video/webm"
  });
  var url = URL.createObjectURL(blob);
  var a = document.createElement("a");
  document.body.appendChild(a);
  a.style = "display: none";
  a.href = url;
  a.download = "test.webm";
  a.click();
  window.URL.revokeObjectURL(url);
}

// demo: to download after 9sec
setTimeout(event =&gt; {
  console.log("stopping");
  mediaRecorder.stop();
}, 9000);
</pre>

<h3 id="Examining_and_controlling_the_recorder_status">Examining and controlling the recorder status</h3>

<p>You can also use the properties of the <code>MediaRecorder</code> object to determine the state of the recording process, and its {{domxref("MediaRecorder.pause", "pause()")}} and {{domxref("MediaRecorder.resume", "resume()")}} methods to pause and resume recording of the source media.</p>

<p>If you need or want to check to see if a specific MIME type is supported, that's possible as well. Just call {{domxref("MediaRecorder.isTypeSupported()")}}.</p>

<h3 id="Examining_potential_input_sources">Examining potential input sources</h3>

<p>If your goal is to record camera and/or microphone input, you may wish to examine the available input devices before beginning the process of constructing the <code>MediaRecorder</code>. To do so, you'll need to call {{domxref("MediaDevices.enumerateDevices", "navigator.mediaDevices.enumerateDevices()")}} to get a list of the available media devices. You can then examine that list and identify the potential input sources, and even filter the list based on desired criteria.</p>

<p>In this code snippet, <code>enumerateDevices()</code> is used to examine the available input devices, locate those which are audio input devices, and create {{HTMLElement("option")}} elements that are then added to a {{HTMLElement("select")}} element representing an input source picker.</p>

<pre class="brush: js">navigator.mediaDevices.enumerateDevices()
.then(function(devices) {
  devices.forEach(function(device) {
    let menu = document.getElementById("inputdevices");
    if (device.kind == "audioinput") {
      let item = document.createElement("option");
      item.innerText = device.label;
      item.value = device.deviceId;
      menu.appendChild(item);
    }
  });
});</pre>

<p>Code similar to this can be used to let the user restrict the set of devices they wish to use.</p>

<h3 id="For_more_information">For more information</h3>

<p>To learn more about using the MediaStream Recording API, see <a href="/en-US/docs/Web/API/MediaStream_Recording_API/Using_the_MediaStream_Recording_API">Using the MediaStream Recording API</a>, which shows how to use the API to record audio clips. A second article, <a href="/en-US/docs/Web/API/MediaStream_Recording_API/Recording_a_media_element">Recording a media element</a>, describes how to receive a stream from an {{HTMLElement("audio")}} or {{HTMLElement("video")}} element and use the captured stream (in this case, recording it and saving it to a local disk).</p>

<h2 id="Reference">Reference</h2>

<dl>
 <dt>{{domxref("BlobEvent")}}</dt>
 <dd>Each time a chunk of media data is finished being recorded, it's delivered to consumers in {{domxref("Blob")}} form using a {{domxref("BlobEvent")}} of type <code>dataavailable</code>.</dd>
 <dt>{{domxref("MediaRecorder")}}</dt>
 <dd>The primary interface that implements the MediaStream Recording API.</dd>
 <dt>{{domxref("MediaRecorderErrorEvent")}}</dt>
 <dd>The interface that represents errors thrown by the MediaStream Recording API. Its {{domxref("MediaRecorderErrorEvent.error", "error")}} property is a {{domxref("DOMException")}} that specifies that error occurred.</dd>
</dl>

<h2 id="Specifications">Specifications</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName("MediaStream Recording", "#MediaRecorderAPI")}}</td>
   <td>{{Spec2("MediaStream Recording")}}</td>
   <td>Initial definition</td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility">Browser compatibility</h2>

<h3 id="MediaRecorder"><code>MediaRecorder</code></h3>

<p>{{Compat("api.MediaRecorder")}}</p>

<h2 id="See_also">See also</h2>

<ul>
 <li><a href="/en-US/docs/Web/API/MediaStream_Recording_API/Using_the_MediaStream_Recording_API">Using the MediaStream Recording API</a></li>
 <li><a href="/en-US/docs/Web/API/MediaStream_Recording_API/Recording_a_media_element">Recording a media element</a></li>
 <li><a href="https://simpl.info/mediarecorder/">simpl.info MediaStream Recording demo</a>, by <a href="https://twitter.com/sw12">Sam Dutton</a></li>
 <li>{{domxref("MediaDevices.getUserMedia")}}</li>
 <li><a href="https://addpipe.com/blog/mediarecorder-api/">HTML5’s Media Recorder API in Action on Chrome and Firefox</a></li>
 <li><a href="https://github.com/ai/audio-recorder-polyfill">MediaRecorder polyfill</a> for Safari and Edge</li>
 <li><a href="https://github.com/chrisjohndigital/TutorRoom">TutorRoom</a>: HTML5 video capture/playback/download using getUserMedia and the MediaRecorder API (<a href="https://github.com/chrisjohndigital/TutorRoom">source on GitHub</a>)</li>
 <li><a href="http://codepen.io/anon/pen/gpmPzm">Simple video recording demo</a></li>
 <li><a href="https://quickblox.github.io/javascript-media-recorder/sample/">Advanced media stream recorder sample</a></li>
 <li><a href="https://github.com/chrisjohndigital/OpenLang">OpenLang</a>: HTML5 video language lab web application using MediaDevices and the MediaStream Recording API for video recording (<a href="https://github.com/chrisjohndigital/OpenLang">source on GitHub</a>)</li>
 <li><a href="https://addpipe.com/blog/safari-technology-preview-73-adds-limited-mediastream-recorder-api-support/">MediaStream Recorder API Now Available in Safari Technology Preview 73</a></li>
</ul>
