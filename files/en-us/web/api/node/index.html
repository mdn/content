---
title: Node
slug: Web/API/Node
tags:
  - API
  - DOM
  - Document
  - Element
  - Interface
  - Node
  - Reference
  - Structure
  - hierarchy
browser-compat: api.Node
---
<p>{{APIRef("DOM")}}</p>

<p>The {{Glossary("DOM")}} <strong><code>Node</code></strong> interface is an abstract base
    class upon which many other DOM API objects are based, thus letting those object types
    to be used similarly and often interchangeably. As an abstract class, there is
  no such thing as a plain <code>Node</code> object. All objects that implement
  <code>Node</code> functionality are based on one of its subclasses. Most notable are
  {{domxref("Document")}}, {{domxref("Element")}}, and {{domxref("DocumentFragment")}}.
</p>

<p>In addition, every kind of DOM node is represented by an interface based on
  <code>Node</code>. These include {{DOMxRef("Attr")}}, {{DOMxRef("CharacterData")}}
  (which {{DOMxRef("Text")}}, {{DOMxRef("Comment")}}, {{DOMxRef("CDATASection")}} and
  {{DOMxRef("ProcessingInstruction")}} are all based on), and {{DOMxRef("DocumentType")}}.</p>

<p>In some cases, a particular feature of the base <code>Node</code> interface may not
  apply to one of its child interfaces; in that case, the inheriting node may
  return <code>null</code> or throw an exception, depending on circumstances. For example,
  attempting to add children to a node type that cannot have children will throw an
  exception.</p>

<p>{{InheritanceDiagram}}</p>

<h2 id="Properties">Properties</h2>

<p><em>In addition to the properties below, <code>Node</code> inherits properties from its
    parent, {{DOMxRef("EventTarget")}}</em>.</p>

<dl>
  <dt>{{DOMxRef("Node.baseURI")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a {{DOMxRef("DOMString")}} representing the base URL of the document
    containing the <code>Node</code>.</dd>
  <dt>{{DOMxRef("Node.childNodes")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a live {{DOMxRef("NodeList")}} containing all the children of this node
    (including elements, text and comments). {{DOMxRef("NodeList")}} being live means that
    if the children of the <code>Node</code> change, the {{DOMxRef("NodeList")}} object is
    automatically updated.</dd>
  <dt>{{DOMxRef("Node.firstChild")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a {{DOMxRef("Node")}} representing the first direct child node of the node,
    or <code>null</code> if the node has no child.</dd>
  <dt>{{DOMxRef("Node.isConnected")}}{{ReadOnlyInline}}</dt>
  <dd>A boolean indicating whether or not the Node is connected (directly or indirectly)
    to the context object, e.g. the {{DOMxRef("Document")}} object in the case of the
    normal DOM, or the {{DOMxRef("ShadowRoot")}} in the case of a shadow DOM.</dd>
  <dt>{{DOMxRef("Node.lastChild")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a {{DOMxRef("Node")}} representing the last direct child node of the node,
    or <code>null</code> if the node has no child.</dd>
  <dt>{{DOMxRef("Node.nextSibling")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a {{DOMxRef("Node")}} representing the next node in the tree, or
    <code>null</code> if there isn't such node.</dd>
  <dt>{{DOMxRef("Node.nodeName")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a {{DOMxRef("DOMString")}} containing the name of the <code>Node</code>. The
    structure of the name will differ with the node type. E.g. An
    {{DOMxRef("HTMLElement")}} will contain the name of the corresponding tag, like
    <code>'audio'</code> for an {{DOMxRef("HTMLAudioElement")}}, a {{DOMxRef("Text")}}
    node will have the <code>'#text'</code> string, or a {{DOMxRef("Document")}} node will
    have the <code>'#document'</code> string.</dd>
  <dt>{{DOMxRef("Node.nodeType")}}{{ReadOnlyInline}}</dt>
  <dd>Returns an <code>unsigned short</code> representing the type of the node. Possible
    values are:
    <table class="standard-table">
      <thead>
        <tr>
          <th scope="col">Name</th>
          <th scope="col">Value</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>ELEMENT_NODE</code></td>
          <td><code>1</code></td>
        </tr>
        <tr>
          <td><code>ATTRIBUTE_NODE</code> {{Deprecated_Inline}}</td>
          <td><code>2</code></td>
        </tr>
        <tr>
          <td><code>TEXT_NODE</code></td>
          <td><code>3</code></td>
        </tr>
        <tr>
          <td><code>CDATA_SECTION_NODE</code></td>
          <td><code>4</code></td>
        </tr>
        <tr>
          <td><code>ENTITY_REFERENCE_NODE</code> {{Deprecated_Inline}}</td>
          <td><code>5</code></td>
        </tr>
        <tr>
          <td><code>ENTITY_NODE</code> {{Deprecated_Inline}}</td>
          <td><code>6</code></td>
        </tr>
        <tr>
          <td><code>PROCESSING_INSTRUCTION_NODE</code></td>
          <td><code>7</code></td>
        </tr>
        <tr>
          <td><code>COMMENT_NODE</code></td>
          <td><code>8</code></td>
        </tr>
        <tr>
          <td><code>DOCUMENT_NODE</code></td>
          <td><code>9</code></td>
        </tr>
        <tr>
          <td><code>DOCUMENT_TYPE_NODE</code></td>
          <td><code>10</code></td>
        </tr>
        <tr>
          <td><code>DOCUMENT_FRAGMENT_NODE</code></td>
          <td><code>11</code></td>
        </tr>
        <tr>
          <td><code>NOTATION_NODE</code> {{Deprecated_Inline}}</td>
          <td><code>12</code></td>
        </tr>
      </tbody>
    </table>
  </dd>
  <dt>{{DOMxRef("Node.nodeValue")}}</dt>
  <dd>Returns / Sets the value of the current node.</dd>
  <dt>{{DOMxRef("Node.ownerDocument")}}{{ReadOnlyInline}}</dt>
  <dd>Returns the {{DOMxRef("Document")}} that this node belongs to. If the node is itself
    a document, returns <code>null</code>.</dd>
  <dt>{{DOMxRef("Node.parentNode")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a {{DOMxRef("Node")}} that is the parent of this node. If there is no such
    node, like if this node is the top of the tree or if doesn't participate in a tree,
    this property returns <code>null</code>.</dd>
  <dt>{{DOMxRef("Node.parentElement")}}{{ReadOnlyInline}}</dt>
  <dd>Returns an {{DOMxRef("Element")}} that is the parent of this node. If the node has
    no parent, or if that parent is not an {{DOMxRef("Element")}}, this property returns
    <code>null</code>.</dd>
  <dt>{{DOMxRef("Node.previousSibling")}}{{ReadOnlyInline}}</dt>
  <dd>Returns a {{DOMxRef("Node")}} representing the previous node in the tree, or
    <code>null</code> if there isn't such node.</dd>
  <dt>{{DOMxRef("Node.textContent")}}</dt>
  <dd>Returns / Sets the textual content of an element and all its descendants.</dd>
</dl>

<h2 id="Methods">Methods</h2>

<p><em>In addition to the properties below, <code>Node</code> inherits methods from its
    parent, {{DOMxRef("EventTarget")}}.</em></p>

<dl>
  <dt>{{DOMxRef("Node.appendChild()", "Node.appendChild(<var>childNode</var>)")}}</dt>
  <dd>Adds the specified <code><var>childNode</var></code> argument as the last child to
    the current node.<br>
    If the argument referenced an existing node on the DOM tree, the node will be detached
    from its current position and attached at the new position.</dd>
  <dt>{{DOMxRef("Node.cloneNode()")}}</dt>
  <dd>Clone a {{DOMxRef("Node")}}, and optionally, all of its contents. By default, it
    clones the content of the node.</dd>
  <dt>{{DOMxRef("Node.compareDocumentPosition()")}}</dt>
  <dd>Compares the position of the current node against another node in any other
    document.</dd>
  <dt>{{DOMxRef("Node.contains()")}}</dt>
  <dd>Returns <code>true</code> or <code>false</code> value indicating whether or not a node is a
    descendant of the calling node.</dd>
  <dt>{{domxref("Node.getBoxQuads()")}} {{experimental_inline}}</dt>
  <dd>Returns a list of the node's CSS boxes relative to another node.</dd>
  <dt>{{DOMxRef("Node.getRootNode()")}}</dt>
  <dd>Returns the context object's root which optionally includes the shadow root if it is
    available.</dd>
  <dt>{{DOMxRef("Node.hasChildNodes()")}}</dt>
  <dd>Returns a {{jsxref("Boolean")}} indicating whether or not the element has any child
    nodes.</dd>
  <dt>{{DOMxRef("Node.insertBefore()")}}</dt>
  <dd>Inserts a {{DOMxRef("Node")}} before the reference node as a child of a specified
    parent node.</dd>
  <dt>{{DOMxRef("Node.isDefaultNamespace()")}}</dt>
  <dd>Accepts a namespace URI as an argument and returns a {{jsxref("Boolean")}} with a
    value of <code>true</code> if the namespace is the default namespace on the given node
    or <code>false</code> if not.</dd>
  <dt>{{DOMxRef("Node.isEqualNode()")}}</dt>
  <dd>Returns a {{jsxref("Boolean")}} which indicates whether or not two nodes are of the
    same type and all their defining data points match.</dd>
  <dt>{{DOMxRef("Node.isSameNode()")}}</dt>
  <dd>Returns a {{jsxref("Boolean")}} value indicating whether or not the two nodes are
    the same (that is, they reference the same object).</dd>
  <dt>{{DOMxRef("Node.lookupPrefix()")}}</dt>
  <dd>Returns a {{DOMxRef("DOMString")}} containing the prefix for a given namespace URI,
    if present, and <code>null</code> if not. When multiple prefixes are possible, the
    result is implementation-dependent.</dd>
  <dt>{{DOMxRef("Node.lookupNamespaceURI()")}}</dt>
  <dd>Accepts a prefix and returns the namespace URI associated with it on the given node
    if found (and <code>null</code> if not). Supplying <code>null</code> for the prefix
    will return the default namespace.</dd>
  <dt>{{DOMxRef("Node.normalize()")}}</dt>
  <dd>Clean up all the text nodes under this element (merge adjacent, remove empty).</dd>
  <dt>{{DOMxRef("Node.removeChild()")}}</dt>
  <dd>Removes a child node from the current element, which must be a child of the current
    node.</dd>
  <dt>{{DOMxRef("Node.replaceChild()")}}</dt>
  <dd>Replaces one child {{DOMxRef("Node")}} of the current one with the second one given
    in parameter.</dd>
</dl>

<h3 id="Obsolete_methods">Obsolete methods</h3>

<dl>
  <dt>{{DOMxRef("Node.hasAttributes()")}} {{deprecated_inline}}</dt>
  <dd>Returns <code>true</code> or <code>false</code> indicating if the element has any attributes, or
    not.</dd>
  <dt>{{DOMxRef("Node.isSupported()")}} {{deprecated_inline}}</dt>
  <dd>Returns <code>true</code> or <code>false</code> containing the result of a test whether the DOM
    implementation implements a specific feature and this feature is supported by the
    specific node.</dd>
</dl>

<h2 id="Examples">Examples</h2>

<h3 id="Remove_all_children_nested_within_a_node">Remove all children nested within a node
</h3>

<pre class="brush: js">function removeAllChildren(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild)
  }
}</pre>

<h4 id="Sample_usage">Sample usage</h4>

<pre class="brush: js">/* Note: or use document.body.textContent = "" */
removeAllChildren(document.body)</pre>

<h3 id="Recurse_through_child_nodes">Recurse through child nodes</h3>

<p>The following function recursively calls a callback function for each node contained by
  a root node (including the root itself):</p>

<pre class="brush: js">function eachNode(rootNode, callback) {
	if (!callback) {
		const nodes = []
		eachNode(rootNode, function(node) {
			nodes.push(node)
		})
		return nodes
	}

	if (false === callback(rootNode)) {
		return false
  }

	if (rootNode.hasChildNodes()) {
		const nodes = rootNode.childNodes
		for (let i = 0, l = nodes.length; i &lt; l; ++i) {
			if (false === eachNode(nodes[i], callback)) {
				return
            }
        }
	}
}
</pre>

<h4 id="Syntax">Syntax</h4>

<pre
  class="brush: js">eachNode(<var>rootNode</var>, <var>callback</var>)</pre>

<h4 id="Description">Description</h4>

<p>Recursively calls a function for each descendant node of
  <code><var>rootNode</var></code> (including the root itself).</p>

<p>If <code><var>callback</var></code> is omitted, the function returns an
  {{jsxref("Array")}} instead, which contains <code><var>rootNode</var></code> and all
  nodes contained within.</p>

<p>If <code><var>callback</var></code> is provided, and it returns
  <code>false</code> when called, the current recursion level is aborted, and the function
  resumes execution at the last parent's level. This can be used to abort loops once a
  node has been found (such as searching for a text node which contains a certain string).
</p>

<h4 id="Parameters">Parameters</h4>

<dl>
  <dt><code><var>rootNode</var></code></dt>
  <dd>The <code>Node</code> object whose descendants will be recursed through.</dd>
  <dt><code><var>callback</var></code> {{optional_inline}}</dt>
  <dd>An optional callback <a
      href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">function</a> that
    receives a <code>Node</code> as its only argument. If omitted, <code>eachNode</code>
    returns an {{jsxref("Array")}} of every node contained within
    <code><var>rootNode</var></code> (including the root itself).</dd>
</dl>

<h4 id="Sample_usage_2">Sample usage</h4>

<p>The following example prints the <a
    href="/en-US/docs/Web/API/Node/textContent"><code>textContent</code></a> properties of
  each <code>&lt;span&gt;</code> element in a <code>&lt;div&gt;</code> element named
  <code>"box"</code>:</p>

<pre class="brush: html">&lt;div id="box"&gt;
  &lt;span&gt;Foo&lt;/span&gt;
  &lt;span&gt;Bar&lt;/span&gt;
  &lt;span&gt;Baz&lt;/span&gt;
&lt;/div&gt;</pre>

<pre class="brush: js">const box = document.getElementById("box")
eachNode(box, function(node) {
  if (null != node.textContent) {
    console.log(node.textContent)
  }
})</pre>

<p>The above will result in the following strings printing to the user's console:</p>

<pre class="brush: js">"\n\t", "Foo", "\n\t", "Bar", "\n\t", "Baz"</pre>

<div class="notecard note">
  <p><strong>Note:</strong> Whitespace forms part of a {{DOMxRef("Text")}} node, meaning
    indentation and newlines form separate <code>Text</code> between the
    <code>Element</code> nodes.</p>
</div>

<h4 id="Realistic_usage">Realistic usage</h4>

<p>The following demonstrates a real-world use of the <code>eachNode()</code> function:
  searching for text on a web-page.</p>

<p>We use a wrapper function named <code>grep</code> to do the searching:</p>

<pre class="brush: js">function grep(parentNode, pattern) {
	const matches = []
	let endScan = false

	eachNode(parentNode, function(node){
		if (endScan) {
			return false
    }

		// Ignore anything which isn't a text node
		if (node.nodeType !== Node.TEXT_NODE) {
			return
    }

		if (typeof pattern === "string") {
			if (-1 !== node.textContent.indexOf(pattern)) {
				matches.push(node)
      }
		}
		else if (pattern.test(node.textContent)) {
			if (!pattern.global) {
				endScan = true
				matches = node
			}
			else {
        matches.push(node)
      }
		}
	})

	return matches
}</pre>

<p>For example, to find {{DOMxRef("Text")}} nodes that contain typos:</p>

<pre class="brush: js">const typos = ["teh", "adn", "btu", "adress", "youre", "msitakes"]
const pattern = new RegExp("\\b(" + typos.join("|") + ")\\b", "gi")
const mistakes = grep(document.body, pattern)
console.log(mistakes)
</pre>

<h2 id="Specifications">Specifications</h2>

{{Specifications}}

<h2 id="Browser_compatibility">Browser compatibility</h2>

<p>{{Compat}}</p>
