---
title: AsyncGenerator
slug: Web/JavaScript/Reference/Global_Objects/AsyncGenerator
tags:
  - Class
  - ECMAScript 2018
  - Generator
  - JavaScript
  - Async Generator
  - Async Iterator
  - Reference
---
<div>{{JSRef}}</div>

<p>The <code><strong>AsyncGenerator</strong></code> object is returned by an {{jsxref("Statements/async_function*", "async generator function")}} and it conforms to both the <a href="/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol">iterable protocol</a> and the <a href="/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol">iterator protocol</a>.</p>

<h2 id="Constructor">Constructor</h2>

<p>This object cannot be instantiated directly. Instead, an <code>AsyncGenerator</code> instance can be returned from an {{jsxref("Statements/async_function*", "async generator function")}}:</p>

<p>Async generators always yield a {{jsxref("Promise")}} object.</p>

<pre class="brush: js">async function* createAsyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

const asyncGen = createAsyncGenerator(); // "AsyncGenerator { }"

asyncGen.next()
  .then(res => console.log(res.value)); // 1
asyncGen.next()
  .then(res => console.log(res.value)); // 2
asyncGen.next()
  .then(res => console.log(res.value)); // 3</pre>

<h2 id="Instance_methods">Instance methods</h2>

<dl>
  <dt>{{jsxref("AsyncGenerator.prototype.next()")}}</dt>
  <dd>Returns a {{jsxref("Promise")}} which will be resolved with the given value yielded by the {{jsxref("Operators/yield", "yield")}} expression.</dd>
  <dt>{{jsxref("AsyncGenerator.prototype.return()")}}</dt>
  <dd>Returns a {{jsxref("Promise")}} which will be resolved with the given value yielded by the {{jsxref("Operators/yield", "yield")}} expression and finishes the generator.</dd>
  <dt>{{jsxref("AsyncGenerator.prototype.throw()")}}</dt>
  <dd>Returns a {{jsxref("Promise")}} that is rejected with an exception thrown from (or uncaught from) within the async generator function and finishes the generator unless the exception is caught within that generator.</dd>
</dl>

<h2 id="Examples">Examples</h2>

<h3 id="async_generator_iteration">Async generator iteration</h3>

<p>The following example iterates over an async generator logging values 1 - 6 to the console, at decreasing time intervals.</p>

<pre class="brush: js;">
function waitFor(time, value) {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(value), time);
  });
}

async function* generate() {
  yield await waitFor(1000, 1);
  yield await waitFor(2000, 2);
  yield await waitFor(400, 3);
  yield await waitFor(800, 4);
  yield await waitFor(150, 5);
  yield await waitFor(50, 6);
  console.log('All done!');
}

async function main() {
  for await (const value of generate()) {
    console.log('value', value);
  }
}

main()
  .catch((e) => console.error('error', e));</pre>

<h2 id="Specifications">Specifications</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-asyncgenerator-objects', 'AsyncGenerator objects')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility">Browser compatibility</h2>

<p>{{Compat("javascript.builtins.AsyncGenerator")}}</p>

<h2 id="See_also">See also</h2>

<ul>
 <li>{{jsxref("Statements/function*", "function*")}}</li>
 <li>{{jsxref("Statements/async_function*", "async function*")}}</li>
 <li>{{jsxref("Operators/function*", '<code>function*</code> expression', "", 1)}}</li>
 <li>{{jsxref("GeneratorFunction")}}</li>
 <li>{{jsxref("AsyncGeneratorFunction")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">The Iterator protocol</a></li>
</ul>
