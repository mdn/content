---
title: Passkeys
slug: Web/Security/Authentication/Passkeys
page-type: guide
sidebar: security
---

Passkeys enable websites to authenticate users without the user having to enter any passwords or other secret codes on the site itself. They're considered [the most secure authentication method available to websites](#security_features_of_passkeys), and we recommend that sites should adopt passkeys as their preferred authentication method, and phase out the use of passwords.

Instead of a shared secret, passkeys depend on public key cryptography. A passkey is a {{glossary("Public-key cryptography", "public/private key pair")}} that's specific to a particular user's account on a particular website.

The private key is stored in a module called an _authenticator_, that's in, or attached to, the user's device. The public key is stored in the website's server. When the user signs in, the authenticator uses the private key to {{glossary("digital signature", "digitally sign")}} a statement about the user's identity, which is called an _assertion_. The website's server can use the public key to verify the assertion's signature, and sign the user in.

## Authenticators

An authenticator generates and securely stores passkeys, and can generate the digital signatures used to sign assertions. Usually, an authenticator also has a means to authenticate users, often with a {{glossary("biometric")}} such as a fingerprint.

An authenticator might be integrated into the device's operating system, like the [Touch ID](https://en.wikipedia.org/wiki/Touch_ID) system in Apple devices or the [Windows Hello](https://en.wikipedia.org/wiki/Windows_10#System_security) system, or it might be a removable module like a [YubiKey](https://en.wikipedia.org/wiki/YubiKey), or it might be an app the user installs, like [Bitwarden](https://bitwarden.com/) or [LastPass](https://www.lastpass.com/).

## The WebAuthn API

To interact with an authenticator, a website uses the [Web Authentication API (WebAuthn)](/en-US/docs/Web/API/Web_Authentication_API).

WebAuthn is an extension of the [Credential Management API](/en-US/docs/Web/API/Credential_Management_API), which is a framework for managing {{glossary("credential", "credentials")}} for various authentication methods, including passwords and federated identity, as well as passkeys.

The two main APIs are:

- {{domxref("CredentialsContainer.create()")}}, which you use to create a new passkey when a user registers on your site.
- {{domxref("CredentialsContainer.get()")}}, which you use to generate an assertion from the user's stored passkey, when the user signs into your site.

## Registration

In this section we'll walk through the flow used to create a new passkey and use it to set up a new user account.

![Overview of user registration with passkeys.](passkeys-register.svg)

When the user asks to register on a site, the site's front-end code first asks its server for a [_challenge_](#challenges): this is a random value generated on the server, that the server will later use to ensure that the resulting passkey was generated in response to this request.

Next, the site's front-end code calls {{domxref("CredentialsContainer.create()")}}. It can specify various options, including:

- **Attestation preferences**: Whether the site is interested in authenticator [attestation](#attestation), and if so, what form the attestation should take.

- **Authenticator preferences**: What type of authenticator to use, and whether the authenticator needs to perform [user verification](#user_verification) before creating the passkey.

- **Challenge**: The [challenge](#challenges) generated by the website's server.

- **Website information**: A human readable name and ID for the website that will be associated with the new passkey. The ID determines the [scope](#passkey_scope) of the resulting passkey.

- **User information**: Information about the user that will be associated with the new passkey, including a human-readable display name, an account identifier, and a human-readable account identifier such as an email address or username.

Depending on the authenticator capabilities and the preferences of the website, the authenticator may ask the user to authorize passkey creation via some [user verification](#user_verification) method: for example, using a {{glossary("biometric")}} such as a fingerprint.

The authenticator then creates a passkey for the account. It stores the private key locally and returns an object containing the public key, challenge, and some additional information. If the authenticator is performing attestation, then this is all {{glossary("digital signature", "digitally signed")}} with either the private key or an [attestation](#attestation) key belonging to the authenticator.

The site's front-end code sends this to the server, which:

- Verifies the attestation, if attestation is taking place
- Verifies that the challenge is the expected value
- Creates a new user account and stores the public key in it along with with the user's account information.

## Sign in

In this section we'll walk through the flow used to sign a user in with a passkey.

![Overview of user sign-in with passkeys.](passkeys-sign-in.svg)

When the user tries to sign in, the site's front-end code again asks the server for a [challenge](#challenges) value.

Next, the site's front-end code calls {{domxref("CredentialsContainer.get()")}}. It can specify various options, including:

- **Acceptable passkeys**: A list of identifiers for the passkeys that the website will accept.

- **Challenge**: The [challenge](#challenges) generated by the website's server.

- **Website ID**: The identifier of the website which is trying to sign the user in. See [Passkey scope](#passkey_scope).

- **User verification**: Whether the authenticator should perform [user verification](#user_verification) before using the passkey.

Next, the browser finds the passkey associated with the current site, and the authenticator which stores this passkey will ask the user to authorize the use of this passkey, including [user verification](#user_verification) if this is requested by the website and supported by the authenticator.

The authenticator will then use the passkey's private key to digitally sign the challenge. This signed challenge is called an _assertion_.

The front-end code sends the assertion to the server, which verifies the signature using the public key it stored. If verification is successful, then the user can be signed in.

### Security features of passkeys

We can note some features of this design that make it inherently more secure than passwords:

- The user never has to remember any secret or enter any secret on the site.
- The server doesn't have to store any secrets: if an attacker steals the user's public key, they can't do anything damaging with it.
- When the user tries to sign in, the browser will only look for passkeys that are associated with the current site. This makes passkeys resistant to [phishing](/en-US/docs/Web/Security/Attacks/Phishing) attacks, because front-end code served from a phishing site like `https://examp1e.com` is not able to use the passkey associated with `https://example.com`.

## Features of WebAuthn

### Assertions

### Challenges

When a website asks an authenticator to create a new passkey or to use an existing passkey, it must provide a _challenge_. This is a random value, specific to the request, that would not be predictable by an attacker. The challenge must be generated in a trusted environment (which generally means, on the server, not the front end).

The website's front-end code passes the challenge into the `create()` or `get()` call, and the browser includes the same value in the object returned by these methods. In the case of `get()`, the challenge value is also part of the input to the digital signature calculated by the authenticator.

When the web server verifies the response from the authenticator, the web server needs to check that the challenge is the same value it originally provided.

The web server should also invalidate the challenge value about 10 minutes, and reject any responses containing the challenge that have arrived after this time.

The challenge represents evidence that the authenticator's response was a response to _this_ request, and not some previous request that an attacker has managed to steal. This kind of attack is known as a _replay attack_.

### Attestation

The security of passkeys depends on the reliability of the authenticators used. For example, if an authenticator does not protect the private keys it stores, then an attacker could steal the keys and impersonate users. In _attestation_, an authenticator provides verifiable evidence to the relying website about its origin, and about the data it produces (such as key pairs or signed assertions). This can help a website decide whether it wants to rely on the authenticator to authenticate its users.

To implement attestation, the authenticator contains a key pair called an _attestation key_, which was built into the device at manufacturing time, and which is {{glossary("digital certificate", "certified")}} as belonging to the organization that made this authenticator. For example, the certificate could state that this authenticator was produced by "Acme Authenticator Incorporated".

When the authenticator creates a new passkey, it signs the resulting object with its attestation key. The relying website verifies the signature and the associated certificate, and then has evidence that the passkey was made by an authenticator produced by "Acme Authenticator Incorporated".

Not all authenticators support attestation, and relying websites can indicate that they are not interested in attestation. In these situations, the object returned by a call to {{domxref("CredentialsContainer.create()")}} may not be signed at all, or it may be signed using the passkey itself (this is referred to as _self attestation_). In these situations, the relying website has no reliable evidence of the authenticator's origin or capabilities.

### User verification

### Passkey scope

The scope of a passkey determines which pages will be able to use the passkey.

determines which websites will be able to use it.

By default, the ID is the domain for the calling document's {{glossary("origin")}}, but the caller may specify any {{glossary("registrable domain")}} that is a suffix of the origin: so for example, a page at `https://auth.example.com` may specify an ID of `example.com`.

### Using a passkey

## Transferring passkeys

## Migrating from passwords
