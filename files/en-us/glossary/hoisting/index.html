---
title: Hoisting
slug: Glossary/Hoisting
tags:
  - CodingScripting
  - Glossary
  - JavaScript
---
<p>Hoisting is a term you will <em>not</em> find used in any normative specification prose prior to <a href="https://www.ecma-international.org/ecma-262/6.0/index.html">ECMAScript® 2015 Language Specification</a>. Hoisting was thought up as a general way of thinking about how execution contexts (specifically the creation and execution phases) work in JavaScript. However, the concept can be a little confusing at first.</p>

<p>Conceptually, for example, a strict definition of hoisting suggests that variable and function declarations are physically moved to the top of your code, but this is not in fact what happens. Instead, the variable and function declarations are put into memory during the <em>compile</em> phase, but stay exactly where you typed them in your code.</p>

<h2 id="Learn_more">Learn more</h2>

<h3 id="Technical_example">Technical example</h3>

<p>One of the advantages of JavaScript putting function declarations into memory before it executes any code segment is that it allows you to use a function before you declare it in your code. For example:</p>

<pre class="brush: js">function catName(name) {
  console.log("My cat's name is " + name);
}

catName("Tiger");

/*
The result of the code above is: "My cat's name is Tiger"
*/
</pre>

<p>The above code snippet is how you would expect to write the code for it to work. Now, let's see what happens when we call the function before we write it:</p>

<pre class="brush: js">catName("Chloe");

function catName(name) {
  console.log("My cat's name is " + name);
}
/*
The result of the code above is: "My cat's name is Chloe"
*/
</pre>

<p>Even though we call the function in our code first, before the function is written, the code still works. This is because of how context execution works in JavaScript.</p>

<p>Hoisting works well with other data types and variables. The variables can be initialized and used before they are declared.</p>

<h3 id="Only_declarations_are_hoisted">Only declarations are hoisted</h3>

<p>JavaScript only hoists declarations, not initializations. If a variable is declared and initialized after using it, the value will be undefined. For example:</p>

<pre class="brush: js">console.log(num); // Returns undefined, as only declaration was hoisted, no initialization has happened at this stage
var num; // Declaration
num = 6; // Initialization</pre>

<p>The example below only has initialization. No hoisting happens so trying to read the variable results in ReferenceError exception.</p>

<pre class="brush: js">console.log(num); // Throws ReferenceError exception
num = 6; // Initialization</pre>

<p>Initializations using <code>let</code> and <code>const</code> are also not hoisted. </p>

<pre class="brush: js">// Example with let:
a = 1; // initialization.
let a; // Throws ReferenceError: Cannot access 'a' before initialization

// Example with const:
a = 1; // initialization.
const a; // Throws SyntaxError: Missing initializer in const declaration
</pre>

<p>Below are more examples demonstrating hoisting.</p>

<pre class="brush: js">// Example 1
// Only y is hoisted

x = 1; // Initialize x, and if not already declared, declare it - but no hoisting as there is no var in the statement.
console.log(x + " " + y); // '1 undefined'
// This prints value of y as undefined as JavaScript only hoists declarations
var y = 2; // Declare and Initialize y

// Example 2
// No hoisting, but since initialization also causes declaration (if not already declared), variables are available.

a = 'Cran'; // Initialize a
b = 'berry'; // Initialize b

console.log(a + "" + b); // 'Cranberry'</pre>

<h3 id="Technical_reference">Technical reference</h3>

<ul>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/var">var statement</a> — MDN</li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Statements/function">function statement</a> — MDN</li>
</ul>
